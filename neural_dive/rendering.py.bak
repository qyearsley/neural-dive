"""
Terminal rendering for Neural Dive.
Uses RenderBackend abstraction for terminal control.
"""

from __future__ import annotations

from collections.abc import Callable
import sys
from typing import TYPE_CHECKING, cast

from neural_dive.backends import RenderBackend
from neural_dive.config import (
    COMPLETION_OVERLAY_MAX_HEIGHT,
    INVENTORY_OVERLAY_MAX_HEIGHT,
    OVERLAY_MAX_HEIGHT,
    OVERLAY_MAX_WIDTH,
    TERMINAL_OVERLAY_MAX_HEIGHT,
    UI_BOTTOM_OFFSET,
)
from neural_dive.conversation import wrap_text
from neural_dive.question_renderers import get_question_renderer
from neural_dive.themes import CharacterSet, ColorScheme

if TYPE_CHECKING:
    from neural_dive.game import Game
    from neural_dive.models import Conversation


class OverlayRenderer:
    """Base class for rendering centered overlay panels."""

    def __init__(
        self,
        backend: RenderBackend,
        max_width: int,
        max_height: int,
        border_color: str,
    ):
        """Initialize overlay renderer.

        Args:
            backend: Render backend instance
            max_width: Maximum overlay width
            max_height: Maximum overlay height
            border_color: Color name for border
        """
        self.backend = backend
        self.max_width = max_width
        self.max_height = max_height
        self.border_color = border_color

        # Calculate centered dimensions
        self.width = min(max_width, backend.width - 4)
        self.height = min(max_height, backend.height - 4)
        self.start_x = (backend.width - self.width) // 2
        self.start_y = (backend.height - self.height) // 2

    def draw_background(self):
        """Draw white background box for overlay."""
        for y in range(self.start_y, self.start_y + self.height):
            self.backend.draw_with_bg(
                self.start_x, y, " " * self.width, "black", "white"
            )

    def draw_border(self):
        """Draw colored border around overlay."""
        _draw_overlay_border(
            self.backend,
            self.start_x,
            self.start_y,
            self.width,
            self.height,
            self.border_color,
        )

    def setup(self):
        """Draw background and border (common setup for all overlays)."""
        self.draw_background()
        self.draw_border()


def create_overlay(
    backend: RenderBackend,
    max_height: int,
    border_color: str,
) -> OverlayRenderer:
    """Factory function for creating and setting up overlays.

    Args:
        backend: Render backend instance
        max_height: Maximum overlay height
        border_color: Color name for border

    Returns:
        Configured OverlayRenderer with background and border already drawn
    """
    overlay = OverlayRenderer(
        backend=backend,
        max_width=OVERLAY_MAX_WIDTH,
        max_height=max_height,
        border_color=border_color,
    )
    overlay.setup()
    return overlay


def draw_game(
    backend: RenderBackend,
    game: Game,
    chars: CharacterSet,
    colors: ColorScheme,
    redraw_all: bool = False,
):
    """Draw the entire game state.

    Args:
        backend: Render backend instance
        game: Game instance
        chars: Character set for rendering
        colors: Color scheme for rendering
        redraw_all: Whether to redraw everything (first draw or after floor change)
    """
    if redraw_all:
        # Clear screen on first draw or floor change
        backend.clear_screen()
        sys.stdout.flush()  # Ensure screen is cleared before drawing

        # Draw map
        _draw_map(backend, game, chars, colors)
    else:
        # Clear old player position
        _clear_old_player_position(backend, game, chars, colors)

        # Clear old NPC positions
        _clear_old_npc_positions(backend, game, chars, colors)

    # Draw all entities
    _draw_entities(backend, game, chars, colors)

    # Draw UI at bottom
    _draw_ui(backend, game, colors)

    # Draw overlays if active
    if game.active_conversation or (
        hasattr(game, "last_answer_response") and game.last_answer_response
    ):
        draw_conversation_overlay(backend, game, colors)

    if game.active_terminal:
        draw_terminal_overlay(backend, game, colors)

    if game.active_inventory:
        draw_inventory_overlay(backend, game, colors)

    if game.active_snippet:
        draw_snippet_overlay(backend, game, colors)

    sys.stdout.flush()


def _draw_map(backend: RenderBackend, game: Game, chars: CharacterSet, colors: ColorScheme) -> None:
    """Draw the game map tiles to the terminal.

    Args:
        backend: Render backend instance for output
        game: Game instance containing map data
        chars: Character set for rendering tiles
        colors: Color scheme for tile colors
    """
    for y in range(len(game.game_map)):
        for x in range(len(game.game_map[0])):
            char = game.game_map[y][x]
            if char == "#":
                backend.draw_text(x, y, chars.wall, colors.wall, bold=True)
            elif char == ".":
                backend.draw_text(x, y, chars.floor, colors.floor)


def _clear_old_player_position(
    backend: RenderBackend, game: Game, chars: CharacterSet, colors: ColorScheme
) -> None:
    """Clear the old player position by redrawing the floor tile.

    Args:
        backend: Render backend instance for output
        game: Game instance with player position data
        chars: Character set for rendering tiles
        colors: Color scheme for tile colors
    """
    if game.old_player_pos:
        old_x, old_y = game.old_player_pos
        char = game.game_map[old_y][old_x]
        if char == ".":
            backend.draw_text(old_x, old_y, chars.floor, colors.floor)


def _is_position_occupied(game: Game, x: int, y: int) -> bool:
    """Check if a position is occupied by any entity.

    Args:
        game: Game instance containing entity data
        x: X coordinate to check
        y: Y coordinate to check

    Returns:
        True if position is occupied by player, NPC, terminal, or stairs
    """
    # Check player
    if game.player.x == x and game.player.y == y:
        return True

    # Check NPCs, terminals, and stairs
    return (
        any(npc.x == x and npc.y == y for npc in game.npcs)
        or any(terminal.x == x and terminal.y == y for terminal in game.terminals)
        or any(stair.x == x and stair.y == y for stair in game.stairs)
    )


def _clear_old_npc_positions(backend: RenderBackend, game: Game, chars: CharacterSet, colors: ColorScheme
) -> None:
    """
    Clear old NPC positions by redrawing floor tiles where NPCs have moved from.

    Args:
        backend: Render backend instance for output
        game: Game instance with NPC position data
        chars: Character set for rendering tiles
        colors: Color scheme for tile colors
    """
    for _npc_name, (old_x, old_y) in game.old_npc_positions.items():
        # If not occupied, redraw the floor tile
        if not _is_position_occupied(game, old_x, old_y):
            char = game.game_map[old_y][old_x]
            if char == ".":
                color_func = getattr(backend, colors.floor, backend.cyan)
                print(backend.move_xy(old_x, old_y) + color_func(chars.floor), end="")
            elif char == "#":
                color_func = getattr(backend, f"bold_{colors.wall}", backend.bold_blue)
                print(backend.move_xy(old_x, old_y) + color_func(chars.wall), end="")

    # Clear the tracking dictionary after processing
    game.old_npc_positions.clear()


def _draw_entities(backend: RenderBackend, game: Game, chars: CharacterSet, colors: ColorScheme) -> None:
    """Draw all game entities including NPCs, terminals, stairs, and player.

    Args:
        backend: Render backend instance for output
        game: Game instance containing entity data
        chars: Character set for rendering entities
        colors: Color scheme for entity colors
    """
    from neural_dive.config import FLOOR_REQUIRED_NPCS
    from neural_dive.entity_renderers import EntityType, get_entity_renderer

    # Get required NPCs for current floor
    required_npcs = FLOOR_REQUIRED_NPCS.get(game.current_floor, set())

    # Draw NPCs using NPCRenderer
    npc_renderer = get_entity_renderer(EntityType.NPC)
    for npc in game.npcs:
        is_required = npc.name in required_npcs
        npc_renderer.render(backend, npc, chars, colors, is_required=is_required)

    # Draw terminals using TerminalRenderer
    terminal_renderer = get_entity_renderer(EntityType.TERMINAL)
    for terminal in game.terminals:
        terminal_renderer.render(backend, terminal, chars, colors)

    # Draw stairs using StairsRenderer
    stairs_renderer = get_entity_renderer(EntityType.STAIRS)
    for stair in game.stairs:
        stairs_renderer.render(backend, stair, chars, colors)

    # Draw item pickups using ItemPickupRenderer
    item_renderer = get_entity_renderer(EntityType.ITEM_PICKUP)
    for pickup in game.item_pickups:
        item_renderer.render(backend, pickup, chars, colors)

    # Draw player using PlayerRenderer
    player_renderer = get_entity_renderer(EntityType.PLAYER)
    player_renderer.render(backend, game.player, chars, colors)


def _draw_ui(backend: RenderBackend, game: Game, colors: ColorScheme) -> None:
    """
    Draw the UI panel at the bottom of the screen.

    Displays floor number, coherence percentage, knowledge count, messages, and controls.

    Args:
        backend: Render backend instance for output
        game: Game instance containing UI state data
        colors: Color scheme for UI colors
    """
    ui_y = backend.height - UI_BOTTOM_OFFSET

    # Separator line - use non-bold for light backgrounds to ensure visibility
    ui_color = cast(Callable[[str], str], getattr(backend, colors.ui_primary, backend.normal))
    print(backend.move_xy(0, ui_y) + ui_color("─" * min(backend.width, 80)), end="")

    # Status line
    score = game.get_current_score()
    knowledge_count = len(game.knowledge_modules)

    status_line = (
        f"Layer {game.current_floor}/{game.max_floors} | "
        f"Coherence: {game.coherence}/{game.max_coherence} | "
        f"Knowledge: {knowledge_count} | "
        f"Score: {score}"
    )
    # Use backend.normal like the instruction line for consistent visibility
    print(backend.move_xy(2, ui_y + 1) + backend.normal + status_line, end="")

    # Message line
    print(backend.move_xy(2, ui_y + 2) + " " * (backend.width - 4), end="")
    msg_color = getattr(backend, f"bold_{colors.ui_warning}", backend.bold_yellow)
    print(
        backend.move_xy(2, ui_y + 2) + msg_color(game.message[: backend.width - 4]),
        end="",
    )

    # Instructions
    if game.active_conversation:
        print(
            backend.move_xy(0, backend.height - 1) + backend.normal + "In conversation - see overlay above",
            end="",
        )
    else:
        print(
            backend.move_xy(0, backend.height - 1)
            + backend.normal
            + "Move: Arrows | Interact: Space/Enter | Stairs: >/< | S: Save | L: Load | Q: Quit",
            end="",
        )


def draw_conversation_overlay(backend: RenderBackend, game: Game, colors: ColorScheme):
    """Draw conversation overlay panel"""
    conv = game.active_conversation

    # If no active conversation, check if we have a completion response to show
    if not conv:
        if hasattr(game, "last_answer_response") and game.last_answer_response:
            draw_completion_overlay(backend, game, colors)
        return

    # Setup overlay with OverlayRenderer
    overlay = create_overlay(backend, OVERLAY_MAX_HEIGHT, colors.ui_secondary)

    # NPC name header
    header = f" {conv.npc_name} "
    header_color = getattr(backend, f"bold_{colors.ui_accent}", backend.bold_magenta)
    print(backend.move_xy(overlay.start_x + 2, overlay.start_y) + header_color(header), end="")

    current_y = overlay.start_y + 2

    # If showing greeting
    if hasattr(game, "show_greeting") and game.show_greeting:
        lines = wrap_text(conv.greeting, overlay.width - 4)
        for line in lines:
            if current_y < overlay.start_y + overlay.height - 2:
                print(backend.move_xy(overlay.start_x + 2, current_y) + backend.black(line), end="")
                current_y += 1
        current_y += 1

        if current_y < overlay.start_y + overlay.height - 2:
            error_color = getattr(backend, f"bold_{colors.ui_error}", backend.bold_red)
            print(
                backend.move_xy(overlay.start_x + 2, current_y)
                + error_color("[Press any key to continue]"),
                end="",
            )
        return

    # Check if we have a pending response to show
    if hasattr(game, "last_answer_response") and game.last_answer_response:
        _draw_response(
            term,
            game,
            overlay.start_x,
            overlay.start_y,
            current_y,
            overlay.width,
            overlay.height,
            colors,
        )
        return

    # Show current question
    if conv.current_question_idx < len(conv.questions):
        _draw_question(
            term,
            conv,
            overlay.start_x,
            overlay.start_y,
            current_y,
            overlay.width,
            overlay.height,
            colors,
            game,
        )


def _draw_response(backend: RenderBackend,
    game: Game,
    start_x: int,
    start_y: int,
    current_y: int,
    overlay_width: int,
    overlay_height: int,
    colors: ColorScheme,
) -> None:
    """
    Draw response to player's answer.

    Args:
        backend: Render backend instance for output
        game: Game instance containing response data
        start_x: X coordinate of overlay start
        start_y: Y coordinate of overlay start
        current_y: Current Y position for drawing
        overlay_width: Width of the overlay
        overlay_height: Height of the overlay
        colors: Color scheme for response colors
    """
    response_text = game.last_answer_response

    # Handle None response text
    if response_text is None:
        return

    # Check if this is a completion response
    is_completion = "CONVERSATION COMPLETE" in response_text

    if not is_completion:
        # Normal response - draw separator line
        separator = "─" * (overlay_width - 4)
        sep_color = getattr(backend, f"bold_{colors.ui_secondary}", backend.bold_blue)
        print(backend.move_xy(start_x + 2, current_y) + sep_color(separator), end="")
        current_y += 1

        # Show "RESPONSE:" header
        success_color = getattr(backend, f"bold_{colors.ui_success}", backend.bold_green)
        print(backend.move_xy(start_x + 2, current_y) + success_color("RESPONSE:"), end="")
        current_y += 2

    # Show response text
    lines = wrap_text(response_text, overlay_width - 4)
    for line in lines:
        if current_y < start_y + overlay_height - 3:
            print(backend.move_xy(start_x + 2, current_y) + backend.black(line), end="")
            current_y += 1
    current_y += 1

    if current_y < start_y + overlay_height - 2:
        error_color = getattr(backend, f"bold_{colors.ui_error}", backend.bold_red)
        print(
            backend.move_xy(start_x + 2, current_y) + error_color("[Press any key to continue]"),
            end="",
        )


def _draw_question(backend: RenderBackend,
    conv: Conversation,
    start_x: int,
    start_y: int,
    current_y: int,
    overlay_width: int,
    overlay_height: int,
    colors: ColorScheme,
    game: Game,
) -> None:
    """Draw current question using appropriate renderer strategy.

    Uses the Strategy pattern to delegate rendering to question-type-specific renderers.

    Args:
        backend: Render backend instance for output
        conv: Active conversation containing the question
        start_x: X coordinate of overlay start
        start_y: Y coordinate of overlay start
        current_y: Current Y position for drawing
        overlay_width: Width of the overlay
        overlay_height: Height of the overlay
        colors: Color scheme for question colors
        game: Game instance for accessing input buffer
    """
    question = conv.questions[conv.current_question_idx]

    # Get appropriate renderer for this question type
    renderer = get_question_renderer(question.question_type)

    # Delegate rendering to the strategy
    renderer.render(
        term=term,
        question=question,
        question_number=conv.current_question_idx + 1,
        total_questions=len(conv.questions),
        start_x=start_x,
        start_y=start_y,
        current_y=current_y,
        overlay_width=overlay_width,
        overlay_height=overlay_height,
        colors=colors,
        game=game,
    )


def draw_completion_overlay(backend: RenderBackend, game: Game, colors: ColorScheme):
    """Draw completion message overlay when conversation is complete."""
    response_text = game.last_answer_response

    # Setup overlay with OverlayRenderer
    overlay = create_overlay(backend, COMPLETION_OVERLAY_MAX_HEIGHT, colors.ui_success)

    current_y = overlay.start_y + 2

    # Big completion banner at top - REMOVED per user request
    # (No longer showing "CONVERSATION COMPLETE" banner)

    # Show response text directly
    lines = wrap_text(response_text, overlay.width - 4) if response_text else []
    for line in lines:
        if current_y < overlay.start_y + overlay.height - 3:
            print(backend.move_xy(overlay.start_x + 2, current_y) + backend.black(line), end="")
            current_y += 1
    current_y += 1

    # Instructions at bottom
    if current_y < overlay.start_y + overlay.height - 2:
        error_color = getattr(backend, f"bold_{colors.ui_error}", backend.bold_red)
        print(
            backend.move_xy(overlay.start_x + 2, current_y)
            + error_color("[Press any key to continue]"),
            end="",
        )


def draw_terminal_overlay(backend: RenderBackend, game: Game, colors: ColorScheme):
    """Draw terminal info overlay"""
    terminal = game.active_terminal
    if not terminal:
        return

    # Setup overlay with OverlayRenderer
    overlay = create_overlay(backend, TERMINAL_OVERLAY_MAX_HEIGHT, colors.terminal)

    # Terminal title header
    header = f" {terminal.title} "
    success_color = getattr(backend, f"bold_{colors.ui_success}", backend.bold_green)
    print(backend.move_xy(overlay.start_x + 2, overlay.start_y) + success_color(header), end="")

    current_y = overlay.start_y + 2

    # Show content
    for line in terminal.content:
        wrapped_lines = wrap_text(line, overlay.width - 4)
        for wrapped_line in wrapped_lines:
            if current_y < overlay.start_y + overlay.height - 2:
                print(
                    backend.move_xy(overlay.start_x + 2, current_y) + backend.black(wrapped_line),
                    end="",
                )
                current_y += 1

    # Instructions at bottom
    error_color = getattr(backend, f"bold_{colors.ui_error}", backend.bold_red)
    print(
        backend.move_xy(overlay.start_x + 2, overlay.start_y + overlay.height - 2)
        + error_color("[Press ESC or any key to close]"),
        end="",
    )


def draw_inventory_overlay(backend: RenderBackend, game: Game, colors: ColorScheme):
    """Draw inventory overlay showing player's items."""
    from neural_dive.items import ItemType

    # Setup overlay with OverlayRenderer
    overlay = create_overlay(backend, INVENTORY_OVERLAY_MAX_HEIGHT, colors.ui_primary)

    # Inventory title header
    header = " INVENTORY "
    success_color = getattr(backend, f"bold_{colors.ui_success}", backend.bold_green)
    print(backend.move_xy(overlay.start_x + 2, overlay.start_y) + success_color(header), end="")

    current_y = overlay.start_y + 2

    # Show inventory count
    inventory_count = game.player_manager.get_inventory_count()
    max_size = game.player_manager.max_inventory_size
    count_text = f"Items: {inventory_count}/{max_size}"
    print(
        backend.move_xy(overlay.start_x + 2, current_y) + backend.black(count_text),
        end="",
    )
    current_y += 2

    # Show items
    if inventory_count == 0:
        print(
            backend.move_xy(overlay.start_x + 2, current_y) + backend.black("(Empty)"),
            end="",
        )
    else:
        # Group items by type
        hint_tokens = game.player_manager.get_items_by_type(ItemType.HINT_TOKEN)
        code_snippets = game.player_manager.get_items_by_type(ItemType.CODE_SNIPPET)

        if hint_tokens:
            print(
                backend.move_xy(overlay.start_x + 2, current_y)
                + backend.black(f"Hint Tokens: {len(hint_tokens)}"),
                end="",
            )
            current_y += 1
            for token in hint_tokens[:3]:  # Show first 3
                if current_y < overlay.start_y + overlay.height - 3:
                    print(
                        backend.move_xy(overlay.start_x + 4, current_y)
                        + backend.black(f"• {token.description}"),
                        end="",
                    )
                    current_y += 1
            current_y += 1

        if code_snippets:
            print(
                backend.move_xy(overlay.start_x + 2, current_y)
                + backend.black(f"Code Snippets: {len(code_snippets)}"),
                end="",
            )
            current_y += 1
            for snippet in code_snippets[:3]:  # Show first 3
                if current_y < overlay.start_y + overlay.height - 3:
                    print(
                        backend.move_xy(overlay.start_x + 4, current_y)
                        + backend.black(f"• {snippet.name}"),
                        end="",
                    )
                    current_y += 1

    # Instructions at bottom
    error_color = getattr(backend, f"bold_{colors.ui_error}", backend.bold_red)
    print(
        backend.move_xy(overlay.start_x + 2, overlay.start_y + overlay.height - 2)
        + error_color("[Press ESC or V to close]"),
        end="",
    )


def draw_snippet_overlay(backend: RenderBackend, game: Game, colors: ColorScheme):
    """Draw code snippet overlay showing reference material."""
    snippet = game.active_snippet
    if not snippet:
        return

    # Setup overlay with OverlayRenderer
    overlay = create_overlay(backend, OVERLAY_MAX_HEIGHT, colors.ui_accent)

    # Snippet title header
    header = f" {snippet['name']} "
    success_color = getattr(backend, f"bold_{colors.ui_success}", backend.bold_green)
    print(backend.move_xy(overlay.start_x + 2, overlay.start_y) + success_color(header), end="")

    current_y = overlay.start_y + 2

    # Show content
    for line in snippet["content"]:
        if current_y < overlay.start_y + overlay.height - 2:
            # No text wrapping for code snippets - preserve formatting
            display_line = line[: overlay.width - 4] if len(line) > overlay.width - 4 else line
            print(
                backend.move_xy(overlay.start_x + 2, current_y) + backend.black(display_line),
                end="",
            )
            current_y += 1

    # Instructions at bottom
    error_color = getattr(backend, f"bold_{colors.ui_error}", backend.bold_red)
    print(
        backend.move_xy(overlay.start_x + 2, overlay.start_y + overlay.height - 2)
        + error_color("[Press ESC or S to close]"),
        end="",
    )


def _draw_overlay_border(backend: RenderBackend, start_x: int, start_y: int, width: int, height: int, color_name: str
) -> None:
    """
    Draw a box border around an overlay using Unicode box-drawing characters.

    Args:
        backend: Render backend instance for output
        start_x: X coordinate of overlay top-left corner
        start_y: Y coordinate of overlay top-left corner
        width: Width of overlay in characters
        height: Height of overlay in lines
        color_name: Name of color for border (from color scheme)
    """
    color_func = getattr(backend, f"bold_{color_name}", backend.bold_blue)

    # Top border
    print(
        backend.move_xy(start_x, start_y) + color_func("┏" + "━" * (width - 2) + "┓"),
        end="",
    )

    # Side borders
    for y in range(start_y + 1, start_y + height - 1):
        print(backend.move_xy(start_x, y) + color_func("┃"), end="")
        print(backend.move_xy(start_x + width - 1, y) + color_func("┃"), end="")

    # Bottom border
    print(
        backend.move_xy(start_x, start_y + height - 1) + color_func("┗" + "━" * (width - 2) + "┛"),
        end="",
    )


def draw_victory_screen(backend: RenderBackend, game: Game, colors: ColorScheme):
    """Draw victory screen with final statistics"""
    stats = game.get_final_stats()

    # Clear screen
    print(backend.home + backend.clear, end="")

    # Calculate centered position
    width = min(70, backend.width - 4)
    height = min(20, backend.height - 4)
    start_x = (backend.width - width) // 2
    start_y = (backend.height - height) // 2

    # Draw background
    for y in range(start_y, start_y + height):
        print(backend.move_xy(start_x, y) + backend.black_on_white(" " * width), end="")

    # Draw border
    success_color = getattr(backend, f"bold_{colors.ui_success}", backend.bold_green)
    _draw_overlay_border(backend, start_x, start_y, width, height, colors.ui_success)

    current_y = start_y + 1

    # Title
    title = "★ VICTORY ★"
    print(
        backend.move_xy(start_x + (width - len(title)) // 2, current_y) + success_color(title), end=""
    )
    current_y += 1

    subtitle = "Neural Dive Complete"
    print(
        backend.move_xy(start_x + (width - len(subtitle)) // 2, current_y) + backend.bold_black(subtitle),
        end="",
    )
    current_y += 2

    # Stats
    def format_time(seconds):
        minutes = int(seconds // 60)
        secs = int(seconds % 60)
        return f"{minutes}m {secs}s"

    stats_lines = [
        f"Final Score: {stats['score']}",
        "",
        f"Questions Answered: {stats['questions_answered']}",
        f"Correct: {stats['questions_correct']} | Wrong: {stats['questions_wrong']}",
        f"Accuracy: {stats['accuracy']:.1f}%",
        "",
        f"NPCs Defeated: {stats['npcs_completed']}",
        f"Knowledge Modules: {stats['knowledge_modules']}",
        f"Final Coherence: {stats['final_coherence']}/{game.max_coherence}",
        "",
        f"Time Played: {format_time(stats['time_played'])}",
        f"Deepest Layer: {stats['current_floor']}/{game.max_floors}",
    ]

    for line in stats_lines:
        if current_y < start_y + height - 2:
            if line == "":
                current_y += 1
                continue
            # Center align stats
            print(backend.move_xy(start_x + 2, current_y) + backend.bold_black(line), end="")
            current_y += 1

    # Footer
    print(
        backend.move_xy(start_x + 2, start_y + height - 2)
        + getattr(backend, f"bold_{colors.ui_primary}", backend.bold)("[Press Q to quit]"),
        end="",
    )

    sys.stdout.flush()

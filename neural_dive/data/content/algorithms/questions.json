{
  "big_o": {
    "question_text": "What is the time complexity of binary search on a sorted array?",
    "topic": "algorithms",
    "answers": [
      {
        "text": "O(n)",
        "correct": false,
        "response": "Not quite. Binary search eliminates half the search space each step."
      },
      {
        "text": "O(log n)",
        "correct": true,
        "response": "Correct! Each comparison halves the search space.",
        "reward_knowledge": "binary_search"
      },
      {
        "text": "O(n log n)",
        "correct": false,
        "response": "That's typical for comparison sorts, not binary search."
      },
      {
        "text": "O(1)",
        "correct": false,
        "response": "Only if you're incredibly lucky on the first try!"
      }
    ]
  },
  "hash_table": {
    "question_text": "What is the average-case time complexity for hash table lookups?",
    "topic": "data_structures",
    "answers": [
      {
        "text": "O(n)",
        "correct": false,
        "response": "That would be the worst case with many collisions."
      },
      {
        "text": "O(log n)",
        "correct": false,
        "response": "That's for balanced trees, not hash tables."
      },
      {
        "text": "O(1)",
        "correct": true,
        "response": "Excellent! Hash tables provide constant-time average-case lookup.",
        "reward_knowledge": "hashing"
      },
      {
        "text": "O(n\u00b2)",
        "correct": false,
        "response": "Way too slow! Hash tables are much more efficient."
      }
    ]
  },
  "tree_height": {
    "question_text": "In a balanced binary search tree with n nodes, what is the height?",
    "topic": "data_structures",
    "answers": [
      {
        "text": "O(n)",
        "correct": false,
        "response": "That's an unbalanced tree - basically a linked list."
      },
      {
        "text": "O(log n)",
        "correct": true,
        "response": "Perfect! Balanced trees maintain logarithmic height.",
        "reward_knowledge": "trees"
      },
      {
        "text": "O(\u221an)",
        "correct": false,
        "response": "Interesting guess, but not quite right."
      },
      {
        "text": "O(1)",
        "correct": false,
        "response": "The height must grow as we add more nodes."
      }
    ]
  },
  "deadlock": {
    "question_text": "Which is NOT a necessary condition for deadlock?",
    "topic": "systems",
    "answers": [
      {
        "text": "Mutual exclusion",
        "correct": false,
        "response": "Mutual exclusion IS required for deadlock."
      },
      {
        "text": "Hold and wait",
        "correct": false,
        "response": "Hold and wait IS a deadlock condition."
      },
      {
        "text": "Preemption",
        "correct": true,
        "response": "Correct! NO preemption is required. If resources can be preempted, deadlock can be avoided.",
        "reward_knowledge": "concurrency"
      },
      {
        "text": "Circular wait",
        "correct": false,
        "response": "Circular wait IS a necessary condition."
      }
    ]
  },
  "cache": {
    "question_text": "In a cache with LRU replacement, what happens on a cache miss?",
    "topic": "systems",
    "answers": [
      {
        "text": "Random page evicted",
        "correct": false,
        "response": "LRU is not random - it's based on recency."
      },
      {
        "text": "Oldest page evicted",
        "correct": false,
        "response": "It's not about absolute age, but recent use."
      },
      {
        "text": "Least recently used evicted",
        "correct": true,
        "response": "Yes! LRU evicts the page with the oldest last access time.",
        "reward_knowledge": "caching"
      },
      {
        "text": "Most recently used evicted",
        "correct": false,
        "response": "That would be MRU, the opposite of LRU!"
      }
    ]
  },
  "tcp_handshake": {
    "question_text": "In TCP's three-way handshake, what is the correct sequence?",
    "topic": "networking",
    "answers": [
      {
        "text": "SYN, ACK, FIN",
        "correct": false,
        "response": "FIN is for closing, not establishing connections."
      },
      {
        "text": "SYN, SYN-ACK, ACK",
        "correct": true,
        "response": "Perfect! This establishes a reliable TCP connection.",
        "reward_knowledge": "networking"
      },
      {
        "text": "ACK, SYN, ACK",
        "correct": false,
        "response": "You can't ACK before SYN - no connection exists yet!"
      },
      {
        "text": "SYN, SYN, ACK",
        "correct": false,
        "response": "The server responds with SYN-ACK, not just SYN."
      }
    ]
  },
  "compiler_phases": {
    "question_text": "Which compiler phase comes immediately after lexical analysis?",
    "topic": "compilers",
    "answers": [
      {
        "text": "Code generation",
        "correct": false,
        "response": "Code generation is near the end of compilation."
      },
      {
        "text": "Optimization",
        "correct": false,
        "response": "Optimization happens after semantic analysis."
      },
      {
        "text": "Parsing (syntax analysis)",
        "correct": true,
        "response": "Correct! Parsing builds the syntax tree from tokens.",
        "reward_knowledge": "compilers"
      },
      {
        "text": "Semantic analysis",
        "correct": false,
        "response": "Semantic analysis comes after parsing."
      }
    ]
  },
  "acid": {
    "question_text": "In database ACID properties, what does the 'I' stand for?",
    "topic": "databases",
    "answers": [
      {
        "text": "Integrity",
        "correct": false,
        "response": "Close, but that's not the official term."
      },
      {
        "text": "Isolation",
        "correct": true,
        "response": "Yes! Isolation ensures concurrent transactions don't interfere.",
        "reward_knowledge": "databases"
      },
      {
        "text": "Indexing",
        "correct": false,
        "response": "Indexing is important but not part of ACID."
      },
      {
        "text": "Idempotency",
        "correct": false,
        "response": "That's a different concept."
      }
    ]
  },
  "p_vs_np": {
    "question_text": "What would it mean if P = NP?",
    "topic": "theory",
    "answers": [
      {
        "text": "Sorting would be O(1)",
        "correct": false,
        "response": "No, that's not related to P vs NP.",
        "enemy_penalty": 45
      },
      {
        "text": "Every efficiently verifiable problem would be efficiently solvable",
        "correct": true,
        "response": "Correct! This would revolutionize computer science.",
        "reward_knowledge": "complexity_theory",
        "enemy_penalty": 45
      },
      {
        "text": "Turing machines would be obsolete",
        "correct": false,
        "response": "P vs NP doesn't affect the model of computation.",
        "enemy_penalty": 45
      },
      {
        "text": "Only applies to quantum computers",
        "correct": false,
        "response": "P and NP are classical complexity classes.",
        "enemy_penalty": 45
      }
    ]
  },
  "dp_memoization": {
    "question_text": "What is the key difference between memoization and tabulation in dynamic programming?",
    "topic": "algorithms",
    "answers": [
      {
        "text": "Memoization is iterative, tabulation is recursive",
        "correct": false,
        "response": "Actually it's the opposite! Memoization uses recursion with caching."
      },
      {
        "text": "Memoization is top-down (recursive), tabulation is bottom-up (iterative)",
        "correct": true,
        "response": "Correct! Memoization caches recursive calls, tabulation builds solutions iteratively.",
        "reward_knowledge": "dynamic_programming"
      },
      {
        "text": "They are the same thing, just different names",
        "correct": false,
        "response": "They're both DP techniques but with different approaches."
      },
      {
        "text": "Memoization is for graphs, tabulation is for strings",
        "correct": false,
        "response": "Both can be used for any DP problem, regardless of data type."
      }
    ]
  },
  "heap_operations": {
    "question_text": "In a binary heap, what is the time complexity to extract the minimum element?",
    "topic": "data_structures",
    "answers": [
      {
        "text": "O(1)",
        "correct": false,
        "response": "Finding the min is O(1), but extraction requires reheapifying."
      },
      {
        "text": "O(log n)",
        "correct": true,
        "response": "Correct! We remove the root and bubble down to maintain heap property.",
        "reward_knowledge": "heaps"
      },
      {
        "text": "O(n)",
        "correct": false,
        "response": "That would be too slow for a heap. Heaps are efficient!"
      },
      {
        "text": "O(n log n)",
        "correct": false,
        "response": "That's typical for sorting, not a single heap operation."
      }
    ]
  },
  "quicksort": {
    "question_text": "What is the average-case time complexity of Quicksort?",
    "topic": "algorithms",
    "answers": [
      {
        "text": "O(n\u00b2)",
        "correct": false,
        "response": "That's the worst case with bad pivots. Average case is better!"
      },
      {
        "text": "O(n log n)",
        "correct": true,
        "response": "Correct! With good pivots, we divide-and-conquer efficiently.",
        "reward_knowledge": "sorting"
      },
      {
        "text": "O(n)",
        "correct": false,
        "response": "Only possible for special cases like counting sort."
      },
      {
        "text": "O(log n)",
        "correct": false,
        "response": "We still need to touch every element at least once."
      }
    ]
  },
  "http_methods": {
    "question_text": "Which HTTP method is idempotent and safe (no side effects)?",
    "topic": "networking",
    "answers": [
      {
        "text": "POST",
        "correct": false,
        "response": "POST creates resources and has side effects - not safe or idempotent."
      },
      {
        "text": "GET",
        "correct": true,
        "response": "Correct! GET retrieves data without modifying state - both safe and idempotent.",
        "reward_knowledge": "http"
      },
      {
        "text": "PUT",
        "correct": false,
        "response": "PUT is idempotent but not safe - it modifies resources."
      },
      {
        "text": "DELETE",
        "correct": false,
        "response": "DELETE is idempotent but not safe - it removes resources."
      }
    ]
  },
  "encryption_types": {
    "question_text": "What's the key advantage of asymmetric encryption over symmetric?",
    "topic": "security",
    "answers": [
      {
        "text": "It's faster to compute",
        "correct": false,
        "response": "Actually asymmetric encryption is much slower than symmetric!"
      },
      {
        "text": "It requires shorter keys",
        "correct": false,
        "response": "Asymmetric keys are typically much longer (2048-4096 bits vs 128-256)."
      },
      {
        "text": "You can share public keys without compromising security",
        "correct": true,
        "response": "Correct! No need to securely exchange keys - the public key can be public!",
        "reward_knowledge": "cryptography"
      },
      {
        "text": "It provides better confidentiality",
        "correct": false,
        "response": "Both provide confidentiality; the key difference is key distribution."
      }
    ]
  },
  "password_hashing": {
    "question_text": "Why should you use bcrypt/Argon2 instead of SHA-256 for password hashing?",
    "topic": "security",
    "answers": [
      {
        "text": "SHA-256 is too slow",
        "correct": false,
        "response": "Actually SHA-256 is too FAST - attackers can brute force quickly!"
      },
      {
        "text": "Bcrypt/Argon2 are intentionally slow and include salt",
        "correct": true,
        "response": "Correct! Slow hashing + salt makes brute force attacks impractical.",
        "reward_knowledge": "password_security"
      },
      {
        "text": "SHA-256 doesn't produce a hash",
        "correct": false,
        "response": "SHA-256 does hash, but it's designed for speed, not password storage."
      },
      {
        "text": "Bcrypt works with quantum computers",
        "correct": false,
        "response": "That's not the key advantage - it's about being computationally expensive."
      }
    ]
  },
  "ipc_methods": {
    "question_text": "Which IPC method allows processes to share memory without copying data?",
    "topic": "systems",
    "answers": [
      {
        "text": "Pipes",
        "correct": false,
        "response": "Pipes copy data through kernel buffers - not true memory sharing."
      },
      {
        "text": "Sockets",
        "correct": false,
        "response": "Sockets also copy data, even on the same machine."
      },
      {
        "text": "Shared memory",
        "correct": true,
        "response": "Correct! Processes map the same physical memory pages into their address space.",
        "reward_knowledge": "ipc"
      },
      {
        "text": "Message queues",
        "correct": false,
        "response": "Message queues copy data between processes."
      }
    ]
  },
  "inodes": {
    "question_text": "What does an inode in a Unix filesystem store?",
    "topic": "systems",
    "answers": [
      {
        "text": "The file name and directory structure",
        "correct": false,
        "response": "File names are stored in directory entries, not inodes!"
      },
      {
        "text": "File metadata (permissions, timestamps, pointers to data blocks)",
        "correct": true,
        "response": "Correct! Inodes store everything about a file except its name and data.",
        "reward_knowledge": "filesystems"
      },
      {
        "text": "Only the file size",
        "correct": false,
        "response": "Inodes store much more: permissions, owner, timestamps, block pointers..."
      },
      {
        "text": "The actual file contents",
        "correct": false,
        "response": "Contents are in data blocks; inodes point to those blocks."
      }
    ]
  },
  "message_queues": {
    "question_text": "What's a key advantage of message queues over direct RPC calls?",
    "topic": "distributed_systems",
    "answers": [
      {
        "text": "They're faster than RPC",
        "correct": false,
        "response": "Message queues actually add latency due to buffering."
      },
      {
        "text": "Decoupling and asynchronous processing",
        "correct": true,
        "response": "Correct! Producers and consumers don't need to be online simultaneously.",
        "reward_knowledge": "message_queues"
      },
      {
        "text": "They guarantee exactly-once delivery",
        "correct": false,
        "response": "Most queues provide at-least-once; exactly-once is very hard!"
      },
      {
        "text": "They eliminate the need for error handling",
        "correct": false,
        "response": "You still need error handling - failures can happen anywhere!"
      }
    ]
  },
  "cap_theorem": {
    "question_text": "In CAP theorem, what does 'partition tolerance' mean?",
    "topic": "distributed_systems",
    "answers": [
      {
        "text": "The system can split data across multiple partitions",
        "correct": false,
        "response": "That's sharding, not partition tolerance!"
      },
      {
        "text": "The system continues operating despite network failures between nodes",
        "correct": true,
        "response": "Correct! P means the system works even when nodes can't communicate.",
        "reward_knowledge": "distributed_systems"
      },
      {
        "text": "The system tolerates disk partition failures",
        "correct": false,
        "response": "CAP is about network partitions, not disk partitions."
      },
      {
        "text": "You can partition your database for better performance",
        "correct": false,
        "response": "That's horizontal scaling, not partition tolerance."
      }
    ]
  },
  "cpu_pipelining": {
    "question_text": "What problem does branch prediction solve in CPU pipelining?",
    "topic": "architecture",
    "answers": [
      {
        "text": "It prevents race conditions",
        "correct": false,
        "response": "That's about concurrency, not pipeline efficiency."
      },
      {
        "text": "It reduces pipeline stalls from conditional branches",
        "correct": true,
        "response": "Correct! By guessing which branch to take, we keep the pipeline full.",
        "reward_knowledge": "cpu_architecture"
      },
      {
        "text": "It increases clock speed",
        "correct": false,
        "response": "Branch prediction doesn't change clock speed, it improves throughput."
      },
      {
        "text": "It adds more cores to the CPU",
        "correct": false,
        "response": "That's multi-core architecture, not branch prediction."
      }
    ]
  },
  "gpu_vs_cpu": {
    "question_text": "Why are GPUs better than CPUs for training neural networks?",
    "topic": "architecture",
    "answers": [
      {
        "text": "GPUs have higher clock speeds",
        "correct": false,
        "response": "Actually CPU cores typically run faster than GPU cores!"
      },
      {
        "text": "GPUs excel at parallel matrix operations",
        "correct": true,
        "response": "Correct! Thousands of cores can process matrix multiplications simultaneously.",
        "reward_knowledge": "gpu_computing"
      },
      {
        "text": "GPUs have more RAM",
        "correct": false,
        "response": "System RAM is typically much larger than GPU memory."
      },
      {
        "text": "GPUs are better at branch prediction",
        "correct": false,
        "response": "GPUs actually have simpler control flow - CPUs are better at branching."
      }
    ]
  },
  "halting_problem": {
    "question_text": "What does the halting problem prove?",
    "topic": "theory",
    "answers": [
      {
        "text": "Some programs will always crash",
        "correct": false,
        "response": "It's not about crashes, it's about decidability."
      },
      {
        "text": "No algorithm can determine if arbitrary programs halt for all inputs",
        "correct": true,
        "response": "Correct! This is a fundamental limit of computation - undecidability exists.",
        "reward_knowledge": "computability_theory"
      },
      {
        "text": "All Turing machines eventually halt",
        "correct": false,
        "response": "Many Turing machines loop forever - that's the whole point!"
      },
      {
        "text": "P = NP",
        "correct": false,
        "response": "The halting problem is about decidability, not complexity classes."
      }
    ]
  },
  "backpropagation": {
    "question_text": "What is backpropagation in neural networks?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Running the network in reverse to generate outputs",
        "correct": false,
        "response": "That's not quite right - it's about learning, not inference."
      },
      {
        "text": "Computing gradients by applying chain rule from output to input",
        "correct": true,
        "response": "Correct! We propagate error gradients backward to update weights.",
        "reward_knowledge": "neural_networks"
      },
      {
        "text": "Adding more layers to make the network deeper",
        "correct": false,
        "response": "That's network architecture, not the training algorithm."
      },
      {
        "text": "Removing neurons that don't contribute to accuracy",
        "correct": false,
        "response": "That's pruning, not backpropagation."
      }
    ]
  },
  "overfitting": {
    "question_text": "What does it mean when a model overfits the training data?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "The model is too simple to capture patterns",
        "correct": false,
        "response": "That's underfitting! Overfitting is the opposite problem."
      },
      {
        "text": "The model memorizes training data but fails to generalize",
        "correct": true,
        "response": "Correct! High training accuracy but poor test performance indicates overfitting.",
        "reward_knowledge": "machine_learning"
      },
      {
        "text": "The model trains too quickly",
        "correct": false,
        "response": "Training speed doesn't directly cause overfitting."
      },
      {
        "text": "The model has perfect accuracy on both train and test sets",
        "correct": false,
        "response": "That would be ideal! Overfitting shows a gap between train and test performance."
      }
    ]
  },
  "tls_handshake": {
    "question_text": "During TLS handshake, what does the server send in the certificate?",
    "topic": "security",
    "answers": [
      {
        "text": "The server's private key",
        "correct": false,
        "response": "Never! Private keys must stay private. Only the public key is shared."
      },
      {
        "text": "The server's public key signed by a Certificate Authority",
        "correct": true,
        "response": "Correct! The CA signature proves the public key belongs to the claimed server.",
        "reward_knowledge": "tls_ssl"
      },
      {
        "text": "The symmetric session key",
        "correct": false,
        "response": "The session key is negotiated after certificate verification."
      },
      {
        "text": "The client's public key",
        "correct": false,
        "response": "The server sends its own certificate, not the client's."
      }
    ]
  },
  "dns_resolution": {
    "question_text": "What is the purpose of DNS caching?",
    "topic": "networking",
    "answers": [
      {
        "text": "To encrypt DNS queries",
        "correct": false,
        "response": "That's DNSSEC or DNS-over-HTTPS, not caching."
      },
      {
        "text": "To reduce latency and load on DNS servers",
        "correct": true,
        "response": "Correct! Caching means we don't need to query authoritative servers every time.",
        "reward_knowledge": "dns"
      },
      {
        "text": "To prevent DNS spoofing attacks",
        "correct": false,
        "response": "Caching can actually make spoofing easier if cache is poisoned!"
      },
      {
        "text": "To assign IP addresses to new domains",
        "correct": false,
        "response": "That's domain registration, not caching."
      }
    ]
  },
  "singleton_pattern": {
    "question_text": "What is the main purpose of the Singleton design pattern?",
    "topic": "design_patterns",
    "answers": [
      {
        "text": "To ensure a class has only one instance with global access point",
        "correct": true,
        "response": "Correct! Singleton ensures only one instance exists and provides global access, useful for configuration managers, database connections, or logging.",
        "reward_knowledge": "design_patterns_creational"
      },
      {
        "text": "To create families of related objects without specifying concrete classes",
        "correct": false,
        "response": "That's the Abstract Factory pattern, not Singleton. Singleton focuses on limiting instantiation to one object.",
        "reward_knowledge": null
      },
      {
        "text": "To define an interface for creating objects in a superclass",
        "correct": false,
        "response": "That's the Factory Method pattern. Singleton is about ensuring single instantiation, not about creating multiple objects.",
        "reward_knowledge": null
      },
      {
        "text": "To attach additional responsibilities to objects dynamically",
        "correct": false,
        "response": "That's the Decorator pattern. Singleton is about controlling instantiation to ensure only one object exists.",
        "reward_knowledge": null
      }
    ]
  },
  "observer_pattern": {
    "question_text": "In the Observer pattern, what happens when the subject's state changes?",
    "topic": "design_patterns",
    "answers": [
      {
        "text": "All registered observers are automatically notified",
        "correct": true,
        "response": "Correct! Observer pattern implements a publish-subscribe mechanism where subjects notify all observers automatically. Perfect for event systems, UI updates, and reactive programming.",
        "reward_knowledge": "design_patterns_behavioral"
      },
      {
        "text": "Observers must poll the subject to check for changes",
        "correct": false,
        "response": "No, that would defeat the purpose. Observer pattern uses push notifications, not polling, making it more efficient.",
        "reward_knowledge": null
      },
      {
        "text": "Only the first observer in the list is notified",
        "correct": false,
        "response": "Observer pattern notifies ALL registered observers, not just one. It's a one-to-many relationship.",
        "reward_knowledge": null
      },
      {
        "text": "The subject creates new observer instances automatically",
        "correct": false,
        "response": "Observers register themselves with the subject. The subject doesn't create observers, it notifies existing ones.",
        "reward_knowledge": null
      }
    ]
  },
  "strategy_pattern": {
    "question_text": "What problem does the Strategy design pattern solve?",
    "topic": "design_patterns",
    "answers": [
      {
        "text": "It allows selecting an algorithm at runtime from a family of algorithms",
        "correct": true,
        "response": "Correct! Strategy pattern encapsulates algorithms and makes them interchangeable. Great for payment methods, sorting strategies, or compression algorithms.",
        "reward_knowledge": "design_patterns_behavioral_advanced"
      },
      {
        "text": "It provides a simplified interface to a complex subsystem",
        "correct": false,
        "response": "That's the Facade pattern. Strategy is about making algorithms interchangeable, not about simplifying interfaces.",
        "reward_knowledge": null
      },
      {
        "text": "It converts the interface of a class into another interface clients expect",
        "correct": false,
        "response": "That's the Adapter pattern. Strategy focuses on encapsulating and selecting algorithms, not interface conversion.",
        "reward_knowledge": null
      },
      {
        "text": "It defines a skeleton of an algorithm, deferring steps to subclasses",
        "correct": false,
        "response": "That's the Template Method pattern. Strategy encapsulates entire algorithms, not just algorithm steps.",
        "reward_knowledge": null
      }
    ]
  },
  "factory_pattern": {
    "question_text": "What's the key advantage of the Factory pattern over direct object construction?",
    "topic": "design_patterns",
    "answers": [
      {
        "text": "It decouples object creation from usage, allowing flexibility",
        "correct": true,
        "response": "Correct! Factory pattern centralizes object creation, making it easy to change implementations, add new types, or inject dependencies without changing client code.",
        "reward_knowledge": "design_patterns_creational_advanced"
      },
      {
        "text": "It makes object creation faster and more efficient",
        "correct": false,
        "response": "Factory pattern isn't about performance. It's about flexibility and maintainability through decoupling.",
        "reward_knowledge": null
      },
      {
        "text": "It automatically prevents memory leaks",
        "correct": false,
        "response": "Factory pattern doesn't directly address memory management. Its benefit is in decoupling creation logic.",
        "reward_knowledge": null
      },
      {
        "text": "It guarantees thread-safety for all objects",
        "correct": false,
        "response": "Factory pattern doesn't inherently provide thread-safety. That requires additional synchronization mechanisms.",
        "reward_knowledge": null
      }
    ]
  },
  "tdd_cycle": {
    "question_text": "What is the correct order of the TDD (Test-Driven Development) cycle?",
    "topic": "testing",
    "answers": [
      {
        "text": "Red (failing test) \u2192 Green (make it pass) \u2192 Refactor",
        "correct": true,
        "response": "Correct! TDD follows Red-Green-Refactor: write a failing test first, implement minimal code to pass it, then refactor while keeping tests green.",
        "reward_knowledge": "tdd_methodology"
      },
      {
        "text": "Write code \u2192 Write tests \u2192 Debug",
        "correct": false,
        "response": "That's traditional testing, not TDD. TDD writes tests BEFORE implementation, driving design from requirements.",
        "reward_knowledge": null
      },
      {
        "text": "Design \u2192 Implement \u2192 Test \u2192 Deploy",
        "correct": false,
        "response": "That's a waterfall approach. TDD is iterative with very short cycles: test-first, then implement.",
        "reward_knowledge": null
      },
      {
        "text": "Refactor \u2192 Write test \u2192 Implement",
        "correct": false,
        "response": "Close, but the order is wrong. TDD starts with a failing test (Red), then implements (Green), then refactors.",
        "reward_knowledge": null
      }
    ]
  },
  "mocking_vs_stubs": {
    "question_text": "What's the key difference between mocks and stubs in testing?",
    "topic": "testing",
    "answers": [
      {
        "text": "Mocks verify behavior (calls made), stubs just provide responses",
        "correct": true,
        "response": "Correct! Mocks assert that specific methods were called with specific arguments. Stubs just return canned responses. Mocks test interaction, stubs isolate dependencies.",
        "reward_knowledge": "test_doubles"
      },
      {
        "text": "Stubs are for unit tests, mocks are for integration tests",
        "correct": false,
        "response": "Both can be used in unit tests. The difference is behavior verification (mocks) vs state verification (stubs).",
        "reward_knowledge": null
      },
      {
        "text": "Mocks are slower but more accurate than stubs",
        "correct": false,
        "response": "Performance isn't the distinction. Mocks verify interactions happened; stubs provide data without verification.",
        "reward_knowledge": null
      },
      {
        "text": "They are the same thing, just different terminology",
        "correct": false,
        "response": "No, they're distinct! Mocks verify behavior (was this method called?), stubs just return values.",
        "reward_knowledge": null
      }
    ]
  },
  "test_pyramid": {
    "question_text": "In the test pyramid, which layer should have the most tests?",
    "topic": "testing",
    "answers": [
      {
        "text": "Unit tests (bottom layer)",
        "correct": true,
        "response": "Correct! The test pyramid has many fast unit tests at the bottom, fewer integration tests in the middle, and few slow E2E tests at the top. Fast feedback is key!",
        "reward_knowledge": "testing_strategy"
      },
      {
        "text": "Integration tests (middle layer)",
        "correct": false,
        "response": "No, integration tests should be fewer than unit tests but more than E2E. They're slower and harder to maintain.",
        "reward_knowledge": null
      },
      {
        "text": "End-to-end tests (top layer)",
        "correct": false,
        "response": "E2E tests should be the fewest! They're slow, brittle, and expensive. Focus on fast unit tests for most coverage.",
        "reward_knowledge": null
      },
      {
        "text": "All layers should have equal numbers of tests",
        "correct": false,
        "response": "That's the ice cream cone anti-pattern! Unit tests should vastly outnumber integration and E2E tests.",
        "reward_knowledge": null
      }
    ]
  },
  "load_balancing": {
    "question_text": "Which load balancing algorithm is best when backend servers have different capacities?",
    "topic": "system_design",
    "answers": [
      {
        "text": "Weighted round-robin",
        "correct": true,
        "response": "Correct! Weighted round-robin assigns more requests to more powerful servers. Servers with higher capacity get proportionally more traffic.",
        "reward_knowledge": "load_balancing"
      },
      {
        "text": "Simple round-robin",
        "correct": false,
        "response": "Simple round-robin treats all servers equally, which wastes capacity if servers have different specs. Use weighted instead.",
        "reward_knowledge": null
      },
      {
        "text": "Random selection",
        "correct": false,
        "response": "Random selection doesn't account for server capacity differences. It could overload weak servers and underutilize strong ones.",
        "reward_knowledge": null
      },
      {
        "text": "Consistent hashing",
        "correct": false,
        "response": "Consistent hashing is for distributed caching/sharding, not for balancing loads across servers of different capacities.",
        "reward_knowledge": null
      }
    ]
  },
  "caching_strategy": {
    "question_text": "What's the difference between write-through and write-back caching?",
    "topic": "system_design",
    "answers": [
      {
        "text": "Write-through writes to cache and DB immediately; write-back writes to cache first, DB later",
        "correct": true,
        "response": "Correct! Write-through is safer (no data loss) but slower. Write-back is faster but risks data loss if cache fails before writeback. Choose based on consistency needs!",
        "reward_knowledge": "caching_strategies"
      },
      {
        "text": "Write-through is for reads; write-back is for writes",
        "correct": false,
        "response": "Both are write strategies! Write-through synchronously updates DB, write-back asynchronously updates DB later.",
        "reward_knowledge": null
      },
      {
        "text": "Write-back requires more memory than write-through",
        "correct": false,
        "response": "Memory isn't the key difference. The difference is WHEN the database is updated: immediately (through) or deferred (back).",
        "reward_knowledge": null
      },
      {
        "text": "They are the same, just different names",
        "correct": false,
        "response": "Very different! Write-through is synchronous and safe. Write-back is asynchronous and faster but can lose data.",
        "reward_knowledge": null
      }
    ]
  },
  "microservices_vs_monolith": {
    "question_text": "What's a key advantage of microservices over a monolithic architecture?",
    "topic": "system_design",
    "answers": [
      {
        "text": "Independent deployment and scaling of individual services",
        "correct": true,
        "response": "Correct! Microservices allow teams to deploy and scale services independently. Update payments without redeploying the entire app. Great for large teams and rapid iteration.",
        "reward_knowledge": "microservices_architecture"
      },
      {
        "text": "Microservices are always faster than monoliths",
        "correct": false,
        "response": "Actually, microservices can be slower due to network overhead between services. The advantage is flexibility, not raw speed.",
        "reward_knowledge": null
      },
      {
        "text": "Microservices eliminate the need for databases",
        "correct": false,
        "response": "Microservices still need data storage! They typically use database-per-service, not eliminate databases.",
        "reward_knowledge": null
      },
      {
        "text": "Microservices are simpler to develop and debug",
        "correct": false,
        "response": "Actually the opposite! Microservices add complexity (distributed systems, network failures, data consistency). Use when the benefits outweigh the complexity.",
        "reward_knowledge": null
      }
    ]
  },
  "database_sharding": {
    "question_text": "What is database sharding?",
    "topic": "system_design",
    "answers": [
      {
        "text": "Horizontally partitioning data across multiple database instances",
        "correct": true,
        "response": "Correct! Sharding splits data by rows across multiple DBs (e.g., users 1-1M on shard1, 1M-2M on shard2). Enables massive scale but adds complexity for cross-shard queries.",
        "reward_knowledge": "database_scaling"
      },
      {
        "text": "Creating read replicas for better read performance",
        "correct": false,
        "response": "That's replication, not sharding. Sharding partitions data; replication copies it. Both are scaling strategies but solve different problems.",
        "reward_knowledge": null
      },
      {
        "text": "Vertically splitting tables by columns into separate databases",
        "correct": false,
        "response": "That's vertical partitioning. Sharding is horizontal partitioning (splitting rows), not columns.",
        "reward_knowledge": null
      },
      {
        "text": "Caching database queries to reduce load",
        "correct": false,
        "response": "That's query caching. Sharding is about distributing data across multiple database servers to handle more data and traffic.",
        "reward_knowledge": null
      }
    ]
  },
  "api_rate_limiting": {
    "type": "yes_no",
    "question_text": "Does API rate limiting help prevent abuse and ensure fair usage?",
    "topic": "web_development",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Rate limiting protects APIs from overuse and abuse.",
    "incorrect_response": "Yes - rate limiting prevents one client from monopolizing API resources."
  },
  "docker_vs_vm": {
    "question_text": "What's a key difference between Docker containers and virtual machines?",
    "topic": "devops",
    "answers": [
      {
        "text": "Containers share the host OS kernel; VMs include a full OS",
        "correct": true,
        "response": "Correct! Containers are lightweight (MBs, start in seconds) by sharing the kernel. VMs include a full OS (GBs, start in minutes). Containers are faster but less isolated.",
        "reward_knowledge": "containerization"
      },
      {
        "text": "VMs are faster to start than containers",
        "correct": false,
        "response": "Opposite! Containers start in seconds; VMs take minutes. Containers don't boot an OS, they just start processes.",
        "reward_knowledge": null
      },
      {
        "text": "Containers provide better security isolation than VMs",
        "correct": false,
        "response": "Actually VMs provide stronger isolation since they don't share the kernel. Containers share the kernel, which can be a security risk.",
        "reward_knowledge": null
      },
      {
        "text": "Docker can only run Linux applications",
        "correct": false,
        "response": "Docker can run Linux, Windows, and Mac containers (with appropriate host OS). The OS-sharing principle applies regardless of platform.",
        "reward_knowledge": null
      }
    ]
  },
  "kubernetes_pods": {
    "question_text": "What is a Kubernetes Pod?",
    "topic": "devops",
    "answers": [
      {
        "text": "The smallest deployable unit, containing one or more containers",
        "correct": true,
        "response": "Correct! A Pod wraps containers that need to work together, sharing network/storage. Pods are ephemeral and managed by higher-level controllers like Deployments.",
        "reward_knowledge": "kubernetes"
      },
      {
        "text": "A cluster of multiple Kubernetes nodes",
        "correct": false,
        "response": "That's a Kubernetes cluster. A Pod is much smaller: the smallest unit containing containers.",
        "reward_knowledge": null
      },
      {
        "text": "A single Docker container running on Kubernetes",
        "correct": false,
        "response": "Close, but Pods can contain multiple containers, not just one. They share the same network namespace.",
        "reward_knowledge": null
      },
      {
        "text": "The control plane that manages worker nodes",
        "correct": false,
        "response": "That's the Kubernetes control plane (master nodes). Pods are workload units that run on worker nodes.",
        "reward_knowledge": null
      }
    ]
  },
  "blue_green_deployment": {
    "type": "multiple_choice",
    "question_text": "What is blue-green deployment?",
    "topic": "devops",
    "answers": [
      {
        "text": "Running two identical environments, switching traffic between them",
        "correct": true,
        "response": "Correct! Blue-green allows instant rollback if issues occur.",
        "reward_knowledge": "deployment_strategies"
      },
      {
        "text": "Color-coding your server racks",
        "correct": false,
        "response": "It's a deployment strategy, not physical organization."
      },
      {
        "text": "Using two different cloud providers",
        "correct": false,
        "response": "It's about environment duplication, not providers."
      },
      {
        "text": "Deploying during off-peak hours",
        "correct": false,
        "response": "That's scheduled deployment, not blue-green."
      }
    ]
  },
  "ci_cd_pipeline": {
    "question_text": "What's the key difference between Continuous Integration (CI) and Continuous Deployment (CD)?",
    "topic": "devops",
    "answers": [
      {
        "text": "CI merges code frequently and runs tests; CD automatically deploys to production",
        "correct": true,
        "response": "Correct! CI ensures code integrates cleanly with automated tests. CD takes it further by automatically deploying passing builds to production. CD requires excellent testing confidence!",
        "reward_knowledge": "ci_cd"
      },
      {
        "text": "CI is for development; CD is for operations teams",
        "correct": false,
        "response": "Both are DevOps practices used by the whole team. CI focuses on integration/testing; CD focuses on automated deployment.",
        "reward_knowledge": null
      },
      {
        "text": "CI requires Docker; CD requires Kubernetes",
        "correct": false,
        "response": "Neither requires specific tools. CI/CD are practices, not tools. You can implement them with various technologies.",
        "reward_knowledge": null
      },
      {
        "text": "CD is just faster CI",
        "correct": false,
        "response": "CD extends CI by adding automated deployment. CI = integrate + test. CD = integrate + test + deploy automatically.",
        "reward_knowledge": null
      }
    ]
  },
  "decision_tree_splits": {
    "question_text": "In decision trees, what criterion is commonly used to decide how to split nodes?",
    "topic": "machine_learning",
    "answers": [
      {
        "text": "Information gain or Gini impurity",
        "correct": true,
        "response": "Correct! Information gain (based on entropy) and Gini impurity both measure how well a split separates classes. The split that maximizes separation is chosen. ID3 uses info gain, CART uses Gini.",
        "reward_knowledge": "decision_trees"
      },
      {
        "text": "Gradient descent on the loss function",
        "correct": false,
        "response": "Gradient descent is for neural networks, not decision trees. Trees use greedy splitting based on information gain or Gini.",
        "reward_knowledge": null
      },
      {
        "text": "Random selection of features",
        "correct": false,
        "response": "Random forests use random feature subsets, but individual trees still choose the best split within that subset using info gain/Gini.",
        "reward_knowledge": null
      },
      {
        "text": "Cross-validation error",
        "correct": false,
        "response": "Cross-validation evaluates the final model, not individual splits. Splits are chosen greedily based on purity measures.",
        "reward_knowledge": null
      }
    ]
  },
  "svm_kernel_trick": {
    "question_text": "What does the kernel trick enable in Support Vector Machines (SVM)?",
    "topic": "machine_learning",
    "answers": [
      {
        "text": "It allows SVM to learn non-linear decision boundaries without explicitly computing high-dimensional features",
        "correct": true,
        "response": "Correct! Kernel trick (e.g., RBF kernel) implicitly maps data to high dimensions where it's linearly separable, without the computational cost. Elegant math: K(x,y) = \u03c6(x)\u00b7\u03c6(y)!",
        "reward_knowledge": "svm"
      },
      {
        "text": "It speeds up training by using fewer support vectors",
        "correct": false,
        "response": "Kernel trick is about handling non-linearity, not reducing support vectors. The number of SVs depends on the data.",
        "reward_knowledge": null
      },
      {
        "text": "It automatically prevents overfitting in SVM",
        "correct": false,
        "response": "Kernel trick enables non-linear boundaries but doesn't prevent overfitting. You still need regularization (C parameter).",
        "reward_knowledge": null
      },
      {
        "text": "It converts SVM into a neural network",
        "correct": false,
        "response": "SVM and neural networks are different algorithms. Kernel trick is specific to SVM for handling non-linearity.",
        "reward_knowledge": null
      }
    ]
  },
  "transformer_attention": {
    "question_text": "What is the key innovation of the attention mechanism in Transformers?",
    "topic": "machine_learning",
    "answers": [
      {
        "text": "It allows the model to focus on relevant parts of the input when processing each token",
        "correct": true,
        "response": "Correct! Attention computes weighted relationships between all input tokens. 'The animal didn't cross the street because it was too tired' - 'it' attends strongly to 'animal'. Revolutionized NLP!",
        "reward_knowledge": "transformers"
      },
      {
        "text": "It eliminates the need for training data",
        "correct": false,
        "response": "Transformers still need training data! Attention is about dynamically weighting input relationships, not unsupervised learning.",
        "reward_knowledge": null
      },
      {
        "text": "It makes models smaller and faster than RNNs",
        "correct": false,
        "response": "Transformers are often LARGER than RNNs! Their advantage is parallelization and better long-range dependencies, not size.",
        "reward_knowledge": null
      },
      {
        "text": "It removes the need for backpropagation",
        "correct": false,
        "response": "Transformers still use backpropagation for training. Attention is a layer type, not a training algorithm.",
        "reward_knowledge": null
      }
    ]
  },
  "regularization_ml": {
    "question_text": "How does dropout regularization help prevent overfitting in neural networks?",
    "topic": "machine_learning",
    "answers": [
      {
        "text": "It randomly disables neurons during training, forcing the network to learn robust features",
        "correct": true,
        "response": "Correct! Dropout randomly drops neurons (e.g., 50% probability) each training step. This prevents co-adaptation and forces redundant representations. Like training an ensemble! Turn off during inference.",
        "reward_knowledge": "ml_regularization"
      },
      {
        "text": "It reduces the number of layers in the network",
        "correct": false,
        "response": "Dropout doesn't change architecture. It temporarily disables random neurons during training to prevent overfitting.",
        "reward_knowledge": null
      },
      {
        "text": "It stops training when validation error increases",
        "correct": false,
        "response": "That's early stopping, not dropout. Both prevent overfitting but in different ways.",
        "reward_knowledge": null
      },
      {
        "text": "It adds noise to the training data",
        "correct": false,
        "response": "Data augmentation adds noise to data. Dropout adds noise to the model by disabling neurons. Both help regularization but differently.",
        "reward_knowledge": null
      }
    ]
  },
  "git_basics": {
    "question_text": "What is the difference between 'git pull' and 'git fetch'?",
    "topic": "version_control",
    "answers": [
      {
        "text": "pull fetches and merges; fetch only downloads changes",
        "correct": true,
        "response": "Correct! 'git fetch' downloads changes but doesn't modify your working directory. 'git pull' = fetch + merge.",
        "reward_knowledge": "git_fundamentals"
      },
      {
        "text": "They do exactly the same thing",
        "correct": false,
        "response": "Not quite! fetch only downloads, while pull also merges the changes into your current branch.",
        "reward_knowledge": null
      },
      {
        "text": "pull is for pushing code, fetch is for getting code",
        "correct": false,
        "response": "Both are for getting code from remote. 'git push' is for sending code.",
        "reward_knowledge": null
      },
      {
        "text": "fetch is deprecated, always use pull",
        "correct": false,
        "response": "Fetch is very useful! It lets you see remote changes before merging them.",
        "reward_knowledge": null
      }
    ]
  },
  "rest_methods": {
    "question_text": "In a RESTful API, which HTTP method should be used to update part of a resource?",
    "topic": "web_development",
    "answers": [
      {
        "text": "PATCH",
        "correct": true,
        "response": "Correct! PATCH is for partial updates. PUT replaces the entire resource. POST creates new resources.",
        "reward_knowledge": "rest_api"
      },
      {
        "text": "GET",
        "correct": false,
        "response": "GET is for retrieving data, not modifying it. GET should be safe and idempotent.",
        "reward_knowledge": null
      },
      {
        "text": "DELETE",
        "correct": false,
        "response": "DELETE removes resources entirely, it doesn't update them.",
        "reward_knowledge": null
      },
      {
        "text": "POST",
        "correct": false,
        "response": "POST is typically for creating new resources, not updating existing ones.",
        "reward_knowledge": null
      }
    ]
  },
  "oop_encapsulation": {
    "question_text": "What is encapsulation in object-oriented programming?",
    "topic": "programming_fundamentals",
    "answers": [
      {
        "text": "Bundling data and methods that operate on that data within a single unit",
        "correct": true,
        "response": "Correct! Encapsulation hides internal state and requires interaction through methods, improving modularity and maintainability.",
        "reward_knowledge": "oop_principles"
      },
      {
        "text": "Creating multiple instances of the same class",
        "correct": false,
        "response": "That's instantiation. Encapsulation is about data hiding and bundling.",
        "reward_knowledge": null
      },
      {
        "text": "Inheriting properties from a parent class",
        "correct": false,
        "response": "That's inheritance. Encapsulation is about bundling data with methods and hiding internals.",
        "reward_knowledge": null
      },
      {
        "text": "Using the same method name with different parameters",
        "correct": false,
        "response": "That's method overloading. Encapsulation is about data hiding and bundling behavior.",
        "reward_knowledge": null
      }
    ]
  },
  "sql_joins": {
    "question_text": "What does an INNER JOIN return in SQL?",
    "topic": "databases",
    "answers": [
      {
        "text": "Only rows that have matching values in both tables",
        "correct": true,
        "response": "Correct! INNER JOIN returns the intersection of two tables based on the join condition.",
        "reward_knowledge": "sql_basics"
      },
      {
        "text": "All rows from both tables, with NULLs where no match exists",
        "correct": false,
        "response": "That's a FULL OUTER JOIN. INNER JOIN only returns matching rows.",
        "reward_knowledge": null
      },
      {
        "text": "All rows from the left table, with NULLs for non-matching right rows",
        "correct": false,
        "response": "That's a LEFT JOIN. INNER JOIN only returns rows with matches in both tables.",
        "reward_knowledge": null
      },
      {
        "text": "A Cartesian product of all rows from both tables",
        "correct": false,
        "response": "That's a CROSS JOIN. INNER JOIN filters for matching rows only.",
        "reward_knowledge": null
      }
    ]
  },
  "exception_handling": {
    "question_text": "Why is it generally bad practice to catch all exceptions with a bare 'except' clause?",
    "topic": "programming_fundamentals",
    "answers": [
      {
        "text": "It can hide bugs and catch system exits, making debugging harder",
        "correct": true,
        "response": "Correct! Catching all exceptions can mask KeyboardInterrupt, SystemExit, and unexpected bugs. Be specific about what you catch!",
        "reward_knowledge": "error_handling"
      },
      {
        "text": "It makes the code run slower",
        "correct": false,
        "response": "Performance isn't the main issue. The problem is hiding bugs and catching things you shouldn't.",
        "reward_knowledge": null
      },
      {
        "text": "You should never use try-except blocks",
        "correct": false,
        "response": "Exception handling is important! Just be specific about which exceptions you're catching.",
        "reward_knowledge": null
      },
      {
        "text": "It's actually a best practice",
        "correct": false,
        "response": "No, it's an anti-pattern! You should catch specific exceptions you know how to handle.",
        "reward_knowledge": null
      }
    ]
  },
  "async_programming": {
    "question_text": "What is the main benefit of asynchronous programming?",
    "topic": "programming_fundamentals",
    "answers": [
      {
        "text": "It allows a program to handle multiple operations concurrently without blocking",
        "correct": true,
        "response": "Correct! Async programming lets you start an I/O operation and do other work while waiting, improving efficiency for I/O-bound tasks.",
        "reward_knowledge": "async_programming"
      },
      {
        "text": "It makes code run faster by using multiple CPU cores",
        "correct": false,
        "response": "That's parallelism/multi-threading. Async is about not blocking on I/O, not using more CPUs.",
        "reward_knowledge": null
      },
      {
        "text": "It eliminates all race conditions",
        "correct": false,
        "response": "Async code can still have race conditions! You still need proper synchronization for shared state.",
        "reward_knowledge": null
      },
      {
        "text": "It's only useful for web servers",
        "correct": false,
        "response": "Async is useful anywhere you have I/O: file operations, databases, network calls, user input, etc.",
        "reward_knowledge": null
      }
    ]
  },
  "code_review": {
    "question_text": "What is the primary goal of code reviews?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Improve code quality, catch bugs, and share knowledge",
        "correct": true,
        "response": "Correct! Code reviews find bugs, improve design, enforce standards, and help the team learn. It's collaboration, not criticism!",
        "reward_knowledge": "software_practices"
      },
      {
        "text": "To find someone to blame when things go wrong",
        "correct": false,
        "response": "No! Code reviews are collaborative, not punitive. The goal is to improve the code, not blame people.",
        "reward_knowledge": null
      },
      {
        "text": "To slow down development and add bureaucracy",
        "correct": false,
        "response": "Good reviews catch bugs before production, saving time overall. They're an investment in quality.",
        "reward_knowledge": null
      },
      {
        "text": "Only senior developers should review code",
        "correct": false,
        "response": "Everyone benefits from reviews! Junior devs can catch bugs too, and they learn by reviewing.",
        "reward_knowledge": null
      }
    ]
  },
  "arrays_vs_linked_lists": {
    "question_text": "When is a linked list preferred over an array?",
    "topic": "data_structures",
    "answers": [
      {
        "text": "When you need frequent insertions/deletions at the beginning or middle",
        "correct": true,
        "response": "Correct! Linked lists have O(1) insertion/deletion once you're at a position. Arrays require shifting elements O(n).",
        "reward_knowledge": "data_structures_basics"
      },
      {
        "text": "When you need fast random access by index",
        "correct": false,
        "response": "Arrays are better for random access O(1). Linked lists require O(n) traversal to reach an index.",
        "reward_knowledge": null
      },
      {
        "text": "When memory efficiency is critical",
        "correct": false,
        "response": "Arrays are more memory efficient! Linked lists need extra space for pointers/references.",
        "reward_knowledge": null
      },
      {
        "text": "Linked lists are always better than arrays",
        "correct": false,
        "response": "Each has trade-offs! Arrays: fast random access. Linked lists: fast insertion/deletion.",
        "reward_knowledge": null
      }
    ]
  },
  "http_status_codes": {
    "question_text": "What does HTTP status code 404 indicate?",
    "topic": "web_development",
    "answers": [
      {
        "text": "The requested resource was not found",
        "correct": true,
        "response": "Correct! 404 Not Found means the server couldn't find the requested resource. It's a client error (4xx).",
        "reward_knowledge": "http_basics"
      },
      {
        "text": "The server encountered an internal error",
        "correct": false,
        "response": "That's 500 Internal Server Error. 404 means the resource doesn't exist.",
        "reward_knowledge": null
      },
      {
        "text": "The request was successful",
        "correct": false,
        "response": "Success is 200 OK. 404 means the resource wasn't found.",
        "reward_knowledge": null
      },
      {
        "text": "The client is not authorized to access the resource",
        "correct": false,
        "response": "That's 401 Unauthorized or 403 Forbidden. 404 means the resource doesn't exist.",
        "reward_knowledge": null
      }
    ]
  },
  "stack_vs_heap": {
    "question_text": "What's the key difference between stack and heap memory?",
    "topic": "systems",
    "answers": [
      {
        "text": "Stack is for local variables with automatic allocation; heap is for dynamic allocation",
        "correct": true,
        "response": "Correct! Stack: LIFO, automatic, fast, limited size. Heap: manual allocation, slower, larger, risk of memory leaks.",
        "reward_knowledge": "memory_management"
      },
      {
        "text": "Stack is slower but safer than heap",
        "correct": false,
        "response": "Stack is actually faster! It's also safer (automatic deallocation), but more limited in size.",
        "reward_knowledge": null
      },
      {
        "text": "Heap is used for function calls, stack is for objects",
        "correct": false,
        "response": "Opposite! Stack is for function calls and local vars. Heap is for dynamically allocated objects.",
        "reward_knowledge": null
      },
      {
        "text": "They're the same thing, just different names",
        "correct": false,
        "response": "Very different! Stack: automatic, limited. Heap: manual, flexible, requires careful management.",
        "reward_knowledge": null
      }
    ]
  },
  "api_versioning": {
    "type": "yes_no",
    "question_text": "Should you version your public API to avoid breaking existing clients?",
    "topic": "web_development",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! API versioning prevents breaking changes for existing users.",
    "incorrect_response": "Yes - versioning (like /v1/, /v2/) protects clients from breaking changes."
  },
  "recursion_vs_iteration": {
    "question_text": "When might recursion be preferred over iteration?",
    "topic": "algorithms",
    "answers": [
      {
        "text": "When the problem has a natural recursive structure like tree traversal",
        "correct": true,
        "response": "Correct! Recursion is elegant for naturally recursive problems: trees, graphs, divide-and-conquer. But watch out for stack overflow!",
        "reward_knowledge": "algorithm_techniques"
      },
      {
        "text": "Recursion is always faster than iteration",
        "correct": false,
        "response": "Actually iteration is usually faster! Recursion has function call overhead. But it can be more readable.",
        "reward_knowledge": null
      },
      {
        "text": "Recursion uses less memory than iteration",
        "correct": false,
        "response": "Recursion uses more memory (call stack)! Each call adds a stack frame. Iteration uses constant space.",
        "reward_knowledge": null
      },
      {
        "text": "You should always use recursion instead of loops",
        "correct": false,
        "response": "Each has its place! Recursion is elegant for some problems, but iteration is often more efficient.",
        "reward_knowledge": null
      }
    ]
  },
  "json_vs_xml": {
    "question_text": "What's a key advantage of JSON over XML for data exchange?",
    "topic": "web_development",
    "answers": [
      {
        "text": "JSON is more concise and easier to parse in JavaScript",
        "correct": true,
        "response": "Correct! JSON is lighter, more readable, and native to JavaScript. Perfect for web APIs and configuration files.",
        "reward_knowledge": "data_formats"
      },
      {
        "text": "JSON supports comments",
        "correct": false,
        "response": "JSON doesn't support comments! That's actually a limitation. XML allows comments.",
        "reward_knowledge": null
      },
      {
        "text": "JSON is more secure than XML",
        "correct": false,
        "response": "Neither is inherently more secure. Both need proper validation to prevent injection attacks.",
        "reward_knowledge": null
      },
      {
        "text": "JSON can represent more complex data structures",
        "correct": false,
        "response": "Both can represent complex data. JSON is simpler; XML has more features like attributes and namespaces.",
        "reward_knowledge": null
      }
    ]
  },
  "dry_principle": {
    "question_text": "What does the DRY principle stand for in software development?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Don't Repeat Yourself",
        "correct": true,
        "response": "Correct! DRY means avoid duplicating code and knowledge. Extract common logic into reusable functions/classes. Makes code easier to maintain!",
        "reward_knowledge": "coding_principles"
      },
      {
        "text": "Debug, Run, Yield",
        "correct": false,
        "response": "Not a real principle! DRY = Don't Repeat Yourself. Avoid code duplication.",
        "reward_knowledge": null
      },
      {
        "text": "Data Requires Yieldability",
        "correct": false,
        "response": "Made up! DRY = Don't Repeat Yourself. Extract repeated code into reusable components.",
        "reward_knowledge": null
      },
      {
        "text": "Deploy Rapidly, Yearly",
        "correct": false,
        "response": "No! DRY = Don't Repeat Yourself. Eliminate duplication to make code more maintainable.",
        "reward_knowledge": null
      }
    ]
  },
  "null_vs_undefined": {
    "question_text": "In JavaScript, what's the difference between null and undefined?",
    "topic": "programming_fundamentals",
    "answers": [
      {
        "text": "undefined means uninitialized; null is an explicit absence of value",
        "correct": true,
        "response": "Correct! undefined: variable declared but not assigned. null: intentionally set to 'no value'. Both are falsy but semantically different.",
        "reward_knowledge": "javascript_fundamentals"
      },
      {
        "text": "They're exactly the same thing",
        "correct": false,
        "response": "Similar but different! null is intentional; undefined means not yet initialized. typeof null is 'object' (bug!), typeof undefined is 'undefined'.",
        "reward_knowledge": null
      },
      {
        "text": "null is a number, undefined is a string",
        "correct": false,
        "response": "Neither! null is its own type (though typeof says 'object'). undefined is also its own type.",
        "reward_knowledge": null
      },
      {
        "text": "You should never use null in JavaScript",
        "correct": false,
        "response": "null is useful for explicitly indicating 'no value'. It communicates intent better than undefined.",
        "reward_knowledge": null
      }
    ]
  },
  "solid_srp": {
    "question_text": "What does the 'S' in SOLID principles stand for?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Single Responsibility Principle",
        "correct": true,
        "response": "Correct! Each class should have one reason to change. Don't mix concerns like business logic and persistence in one class.",
        "reward_knowledge": "solid_principles"
      },
      {
        "text": "Simple Reusability Pattern",
        "correct": false,
        "response": "Not quite! S = Single Responsibility Principle. A class should have only one reason to change.",
        "reward_knowledge": null
      },
      {
        "text": "Structured Programming",
        "correct": false,
        "response": "No. S = Single Responsibility Principle. Each class should have one, well-defined purpose.",
        "reward_knowledge": null
      },
      {
        "text": "Synchronized Operations",
        "correct": false,
        "response": "Incorrect! S = Single Responsibility Principle. Each class should do one thing well.",
        "reward_knowledge": null
      }
    ]
  },
  "solid_ocp": {
    "question_text": "What does the 'O' in SOLID principles stand for?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Open/Closed Principle",
        "correct": true,
        "response": "Correct! Software entities should be open for extension but closed for modification. Use interfaces and inheritance to add new behavior without changing existing code.",
        "reward_knowledge": "solid_principles"
      },
      {
        "text": "Object-Oriented Programming",
        "correct": false,
        "response": "No. O = Open/Closed Principle. Classes should be open for extension, closed for modification.",
        "reward_knowledge": null
      },
      {
        "text": "Optimized Code Principle",
        "correct": false,
        "response": "Not quite! O = Open/Closed Principle. Design so you can extend without modifying existing code.",
        "reward_knowledge": null
      },
      {
        "text": "Operator Overloading",
        "correct": false,
        "response": "Incorrect! O = Open/Closed Principle. Open for extension, closed for modification.",
        "reward_knowledge": null
      }
    ]
  },
  "solid_lsp": {
    "question_text": "What does the 'L' in SOLID principles stand for?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Liskov Substitution Principle",
        "correct": true,
        "response": "Correct! Subtypes must be substitutable for their base types without breaking the program. Named after Barbara Liskov, this ensures polymorphism works correctly.",
        "reward_knowledge": "solid_principles"
      },
      {
        "text": "Layered Architecture",
        "correct": false,
        "response": "No. L = Liskov Substitution Principle. Subtypes should be substitutable for their base types.",
        "reward_knowledge": null
      },
      {
        "text": "Loose Coupling",
        "correct": false,
        "response": "Not quite! L = Liskov Substitution Principle. If S is a subtype of T, you should be able to replace T with S.",
        "reward_knowledge": null
      },
      {
        "text": "Logical Separation",
        "correct": false,
        "response": "Incorrect! L = Liskov Substitution Principle. Derived classes must be substitutable for base classes.",
        "reward_knowledge": null
      }
    ]
  },
  "solid_isp": {
    "question_text": "What does the 'I' in SOLID principles stand for?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Interface Segregation Principle",
        "correct": true,
        "response": "Correct! No client should be forced to depend on methods it doesn't use. Many specific interfaces are better than one general-purpose interface.",
        "reward_knowledge": "solid_principles"
      },
      {
        "text": "Inheritance Pattern",
        "correct": false,
        "response": "No. I = Interface Segregation Principle. Split large interfaces into smaller, more specific ones.",
        "reward_knowledge": null
      },
      {
        "text": "Implementation Hiding",
        "correct": false,
        "response": "Not quite! I = Interface Segregation Principle. Clients shouldn't depend on interfaces they don't use.",
        "reward_knowledge": null
      },
      {
        "text": "Immutable Objects",
        "correct": false,
        "response": "Incorrect! I = Interface Segregation Principle. Make interfaces focused and specific.",
        "reward_knowledge": null
      }
    ]
  },
  "solid_dip": {
    "question_text": "What does the 'D' in SOLID principles stand for?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Dependency Inversion Principle",
        "correct": true,
        "response": "Correct! Depend on abstractions, not concretions. High-level modules shouldn't depend on low-level modules; both should depend on abstractions.",
        "reward_knowledge": "solid_principles"
      },
      {
        "text": "Data Encapsulation",
        "correct": false,
        "response": "No. D = Dependency Inversion Principle. Depend on abstractions (interfaces), not concrete implementations.",
        "reward_knowledge": null
      },
      {
        "text": "Design Patterns",
        "correct": false,
        "response": "Not quite! D = Dependency Inversion Principle. High-level code should depend on abstractions.",
        "reward_knowledge": null
      },
      {
        "text": "Dynamic Dispatch",
        "correct": false,
        "response": "Incorrect! D = Dependency Inversion Principle. Depend on interfaces, not concrete classes.",
        "reward_knowledge": null
      }
    ]
  },
  "turing_completeness": {
    "question_text": "What does it mean for a system to be Turing complete?",
    "topic": "theory",
    "answers": [
      {
        "text": "It can simulate any Turing machine given enough time and memory",
        "correct": true,
        "response": "Correct! Turing completeness means the system can compute anything computable. Even simple systems like Rule 110 cellular automata are Turing complete!",
        "reward_knowledge": "computability",
        "enemy_penalty": 45
      },
      {
        "text": "It can solve the halting problem",
        "correct": false,
        "response": "No! The halting problem is undecidable even for Turing complete systems. Turing completeness is about computational power, not decidability.",
        "enemy_penalty": 45
      },
      {
        "text": "It always terminates for any input",
        "correct": false,
        "response": "Opposite! Turing complete systems can run forever. That's why the halting problem is undecidable.",
        "enemy_penalty": 45
      },
      {
        "text": "It can only execute a fixed set of programs",
        "correct": false,
        "response": "No! Turing completeness means universal computation - any computable function can be computed.",
        "enemy_penalty": 45
      }
    ]
  },
  "gradient_descent": {
    "question_text": "What is the purpose of gradient descent in training neural networks?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "To iteratively minimize the loss function by updating weights in the direction of steepest descent",
        "correct": true,
        "response": "Correct! Gradient descent follows the negative gradient (slope) to find local minima of the loss function. Learning rate controls step size.",
        "reward_knowledge": "optimization",
        "enemy_penalty": 45
      },
      {
        "text": "To increase the loss function value",
        "correct": false,
        "response": "Opposite! We want to MINIMIZE loss, not maximize it. That's why we follow the negative gradient.",
        "enemy_penalty": 45
      },
      {
        "text": "To add more layers to the network",
        "correct": false,
        "response": "Gradient descent is an optimization algorithm, not an architecture modification technique.",
        "enemy_penalty": 45
      },
      {
        "text": "To eliminate the need for training data",
        "correct": false,
        "response": "No! Gradient descent requires training data to compute loss and gradients. It's a supervised learning technique.",
        "enemy_penalty": 45
      }
    ]
  },
  "finite_automata": {
    "question_text": "What type of language can a deterministic finite automaton (DFA) recognize?",
    "topic": "theory",
    "answers": [
      {
        "text": "Regular languages",
        "correct": true,
        "response": "Correct! DFAs recognize exactly the regular languages - same power as regular expressions and NFAs. They have finite memory (just the current state).",
        "reward_knowledge": "automata_theory",
        "enemy_penalty": 45
      },
      {
        "text": "Context-free languages",
        "correct": false,
        "response": "That's pushdown automata! DFAs can't count or match nested structures. They recognize regular languages only.",
        "enemy_penalty": 45
      },
      {
        "text": "All computable languages",
        "correct": false,
        "response": "That would require Turing completeness. DFAs have finite memory and can only recognize regular languages.",
        "enemy_penalty": 45
      },
      {
        "text": "Context-sensitive languages",
        "correct": false,
        "response": "That requires a linear bounded automaton. DFAs are much weaker - they recognize only regular languages.",
        "enemy_penalty": 45
      }
    ]
  },
  "universal_approximation": {
    "question_text": "What does the Universal Approximation Theorem tell us about neural networks?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "A neural network with one hidden layer can approximate any continuous function",
        "correct": true,
        "response": "Correct! With enough hidden neurons, even shallow networks are universal function approximators. But deeper networks often learn more efficiently!",
        "reward_knowledge": "neural_theory",
        "enemy_penalty": 45
      },
      {
        "text": "Neural networks can perfectly fit any dataset without error",
        "correct": false,
        "response": "No! The theorem is about approximation capacity, not optimization. Training might not find the optimal weights, and we want generalization, not perfect fit!",
        "enemy_penalty": 45
      },
      {
        "text": "All neural networks will converge to the same solution",
        "correct": false,
        "response": "False! Training is non-convex with many local minima. Different initializations lead to different solutions.",
        "enemy_penalty": 45
      },
      {
        "text": "Deep networks are unnecessary since shallow ones suffice",
        "correct": false,
        "response": "Misleading! While shallow networks have representational power, deep networks learn efficiently with exponentially fewer neurons for some functions.",
        "enemy_penalty": 45
      }
    ]
  },
  "merge_sort": {
    "question_text": "What is the space complexity of merge sort?",
    "topic": "algorithms",
    "answers": [
      {
        "text": "O(1)",
        "correct": false,
        "response": "Merge sort requires additional space for merging."
      },
      {
        "text": "O(log n)",
        "correct": false,
        "response": "Not quite. Think about the auxiliary space needed."
      },
      {
        "text": "O(n)",
        "correct": true,
        "response": "Correct! Merge sort needs O(n) auxiliary space.",
        "reward_knowledge": "merge_sort"
      },
      {
        "text": "O(n\u00b2)",
        "correct": false,
        "response": "Too much! Merge sort is more space-efficient than that."
      }
    ]
  },
  "bfs_vs_dfs": {
    "question_text": "Which graph traversal guarantees finding the shortest path in an unweighted graph?",
    "topic": "algorithms",
    "answers": [
      {
        "text": "Depth-First Search",
        "correct": false,
        "response": "DFS explores as deep as possible first."
      },
      {
        "text": "Breadth-First Search",
        "correct": true,
        "response": "Correct! BFS explores level by level, finding shortest paths.",
        "reward_knowledge": "graph_traversal"
      },
      {
        "text": "Both are equivalent",
        "correct": false,
        "response": "They have different properties!"
      },
      {
        "text": "Neither guarantees it",
        "correct": false,
        "response": "One of them does guarantee it."
      }
    ]
  },
  "greedy_algorithms": {
    "question_text": "Which problem can be solved optimally using a greedy algorithm?",
    "topic": "algorithms",
    "answers": [
      {
        "text": "0/1 Knapsack",
        "correct": false,
        "response": "0/1 Knapsack requires dynamic programming."
      },
      {
        "text": "Traveling Salesman",
        "correct": false,
        "response": "TSP is NP-hard, greedy doesn't guarantee optimal."
      },
      {
        "text": "Huffman Coding",
        "correct": true,
        "response": "Yes! Huffman coding is a classic greedy algorithm.",
        "reward_knowledge": "greedy"
      },
      {
        "text": "Longest Common Subsequence",
        "correct": false,
        "response": "LCS needs dynamic programming."
      }
    ]
  },
  "amortized_analysis": {
    "question_text": "What does amortized time complexity measure?",
    "topic": "algorithms",
    "answers": [
      {
        "text": "Worst case only",
        "correct": false,
        "response": "Amortized analysis considers sequences of operations."
      },
      {
        "text": "Best case only",
        "correct": false,
        "response": "No, it's about average over sequences."
      },
      {
        "text": "Average over sequence",
        "correct": true,
        "response": "Correct! Amortized analysis averages cost over operation sequences.",
        "reward_knowledge": "amortized"
      },
      {
        "text": "Space complexity",
        "correct": false,
        "response": "Amortized analysis is about time, not space."
      }
    ]
  },
  "trie_usage": {
    "question_text": "What is a trie (prefix tree) best used for?",
    "topic": "data_structures",
    "answers": [
      {
        "text": "Sorting numbers",
        "correct": false,
        "response": "A trie (prefix tree) isn't designed for sorting numbers. Tries are tree structures where each node represents a character, making them perfect for string operations like autocomplete."
      },
      {
        "text": "String prefix matching",
        "correct": true,
        "response": "Perfect! Tries excel at prefix-based string operations.",
        "reward_knowledge": "trie"
      },
      {
        "text": "Graph traversal",
        "correct": false,
        "response": "Tries are trees, not general graphs. A trie stores strings where each path from root represents a string prefix, making prefix matching O(m) where m is string length\\!"
      },
      {
        "text": "Random access",
        "correct": false,
        "response": "Arrays give O(1) random access by index. Tries are for string prefix operations - each character is a node, paths spell words. Perfect for autocomplete and spell checking\\!"
      }
    ]
  },
  "bloom_filter": {
    "question_text": "What is a key characteristic of a Bloom filter?",
    "topic": "data_structures",
    "answers": [
      {
        "text": "No false positives",
        "correct": false,
        "response": "Bloom filters CAN have false positives\\! A Bloom filter is a probabilistic data structure using multiple hash functions. It can wrongly say an item exists (false positive) but never wrongly say it doesn't (no false negatives)."
      },
      {
        "text": "No false negatives",
        "correct": true,
        "response": "Correct! Bloom filters never have false negatives.",
        "reward_knowledge": "bloom_filter"
      },
      {
        "text": "Perfect accuracy",
        "correct": false,
        "response": "Bloom filters sacrifice perfect accuracy for space efficiency. They use a bit array and hash functions to test set membership - fast and compact but can give false positives. Never false negatives though\\!"
      },
      {
        "text": "Slow lookups",
        "correct": false,
        "response": "Bloom filters ARE very fast - that's correct\\! But the KEY characteristic is no false negatives. Bloom filters are space-efficient probabilistic data structures that may say 'yes' when wrong, but never say 'no' when wrong."
      }
    ]
  },
  "skip_list": {
    "question_text": "What is the expected time complexity of search in a skip list?",
    "topic": "data_structures",
    "answers": [
      {
        "text": "O(1)",
        "correct": false,
        "response": "Skip lists are faster than O(1)\\! They're probabilistic data structures with multiple layers of linked lists, providing O(log n) average search time - like balanced trees but simpler."
      },
      {
        "text": "O(log n)",
        "correct": true,
        "response": "Correct! Skip lists provide O(log n) expected search time.",
        "reward_knowledge": "skip_list"
      },
      {
        "text": "O(n)",
        "correct": false,
        "response": "Skip lists are faster\\! They use multiple levels of express lanes (like highways) to skip over elements, achieving O(log n) expected search in a linked list structure."
      },
      {
        "text": "O(n log n)",
        "correct": false,
        "response": "O(n log n) is for sorting algorithms. Skip lists achieve O(log n) search by maintaining multiple layers, where higher layers skip more elements - probabilistic balanced search\\!"
      }
    ]
  },
  "b_tree": {
    "question_text": "Why are B-trees commonly used in databases?",
    "topic": "data_structures",
    "answers": [
      {
        "text": "They use less memory",
        "correct": false,
        "response": "Memory isn't the key reason. B-trees are designed for disk storage where each node holds many keys. Wide nodes mean fewer disk seeks since disk I/O is expensive (milliseconds vs nanoseconds for RAM)."
      },
      {
        "text": "Minimize disk I/O",
        "correct": true,
        "response": "Yes! B-trees minimize expensive disk operations.",
        "reward_knowledge": "b_tree"
      },
      {
        "text": "Faster than hash tables",
        "correct": false,
        "response": "Hash tables are faster for exact key lookups (O(1)). B-trees excel at range queries and are optimized for disk I/O - each node is a disk block, minimizing expensive seeks."
      },
      {
        "text": "Easier to implement",
        "correct": false,
        "response": "B-trees are actually complex\\! But they're used because they minimize disk I/O. Wide nodes (many keys per node) mean fewer disk accesses, critical for database performance."
      }
    ]
  },
  "chomsky_hierarchy": {
    "question_text": "In the Chomsky hierarchy, which languages can a finite automaton recognize?",
    "topic": "theory",
    "answers": [
      {
        "text": "Regular languages",
        "correct": true,
        "response": "Correct! Finite automata recognize regular languages.",
        "reward_knowledge": "chomsky"
      },
      {
        "text": "Context-free languages",
        "correct": false,
        "response": "Context-free needs push-down automata."
      },
      {
        "text": "All languages",
        "correct": false,
        "response": "Finite automata are limited in power."
      },
      {
        "text": "No languages",
        "correct": false,
        "response": "They can recognize regular languages!"
      }
    ]
  },
  "rice_theorem": {
    "question_text": "What does Rice's Theorem state?",
    "topic": "theory",
    "answers": [
      {
        "text": "All problems are decidable",
        "correct": false,
        "response": "Many problems are undecidable!"
      },
      {
        "text": "Non-trivial properties of programs are undecidable",
        "correct": true,
        "response": "Correct! Rice's Theorem is fundamental to computability.",
        "reward_knowledge": "rice"
      },
      {
        "text": "P = NP",
        "correct": false,
        "response": "Rice's Theorem doesn't address P vs NP."
      },
      {
        "text": "All algorithms terminate",
        "correct": false,
        "response": "The halting problem shows this is undecidable."
      }
    ]
  },
  "reduction": {
    "question_text": "In complexity theory, what does a reduction prove?",
    "topic": "theory",
    "answers": [
      {
        "text": "A problem is easy",
        "correct": false,
        "response": "Reductions often prove hardness!"
      },
      {
        "text": "Relative difficulty",
        "correct": true,
        "response": "Yes! Reductions show one problem is at least as hard as another.",
        "reward_knowledge": "reduction"
      },
      {
        "text": "Problems are identical",
        "correct": false,
        "response": "Reductions show relationships, not equivalence."
      },
      {
        "text": "Algorithms are optimal",
        "correct": false,
        "response": "Reductions are about problem hardness."
      }
    ]
  },
  "space_hierarchy": {
    "question_text": "What does the Space Hierarchy Theorem state?",
    "topic": "theory",
    "answers": [
      {
        "text": "All space bounds are equivalent",
        "correct": false,
        "response": "Different space bounds have different power!"
      },
      {
        "text": "More space = more problems solvable",
        "correct": true,
        "response": "Correct! More space enables solving harder problems.",
        "reward_knowledge": "space_hierarchy"
      },
      {
        "text": "Space and time are identical",
        "correct": false,
        "response": "Space and time are related but distinct."
      },
      {
        "text": "Constant space solves everything",
        "correct": false,
        "response": "Many problems require more space."
      }
    ]
  },
  "batch_normalization": {
    "question_text": "What is the primary benefit of batch normalization?",
    "topic": "machine_learning",
    "answers": [
      {
        "text": "Reduces model size",
        "correct": false,
        "response": "Batch norm doesn't reduce model size."
      },
      {
        "text": "Stabilizes training",
        "correct": true,
        "response": "Yes! Batch norm reduces internal covariate shift.",
        "reward_knowledge": "batch_norm"
      },
      {
        "text": "Prevents all overfitting",
        "correct": false,
        "response": "It helps but doesn't prevent all overfitting."
      },
      {
        "text": "Eliminates need for activation",
        "correct": false,
        "response": "Activation functions are still needed!"
      }
    ]
  },
  "dropout": {
    "question_text": "How does dropout regularization work?",
    "topic": "machine_learning",
    "answers": [
      {
        "text": "Removes layers",
        "correct": false,
        "response": "Dropout doesn't remove entire layers."
      },
      {
        "text": "Randomly drops neurons during training",
        "correct": true,
        "response": "Correct! Dropout randomly deactivates neurons.",
        "reward_knowledge": "dropout"
      },
      {
        "text": "Reduces learning rate",
        "correct": false,
        "response": "That's a different technique."
      },
      {
        "text": "Adds noise to inputs",
        "correct": false,
        "response": "Dropout affects neurons, not inputs directly."
      }
    ]
  },
  "learning_rate_schedule": {
    "question_text": "Why use a learning rate schedule?",
    "topic": "machine_learning",
    "answers": [
      {
        "text": "Speeds up training only",
        "correct": false,
        "response": "It's about convergence quality too."
      },
      {
        "text": "Helps converge to better minima",
        "correct": true,
        "response": "Yes! Schedules help escape local minima and converge better.",
        "reward_knowledge": "lr_schedule"
      },
      {
        "text": "Prevents underfitting",
        "correct": false,
        "response": "Schedules don't directly address underfitting."
      },
      {
        "text": "Reduces model size",
        "correct": false,
        "response": "Learning rate doesn't affect model size."
      }
    ]
  },
  "bias_variance_tradeoff": {
    "type": "multiple_choice",
    "question_text": "In ML, what does high bias typically indicate?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Underfitting - model is too simple",
        "correct": true,
        "response": "Correct! High bias means the model is too simple to capture patterns."
      },
      {
        "text": "Overfitting - model is too complex",
        "correct": false,
        "response": "Overfitting is associated with high variance, not high bias."
      },
      {
        "text": "Perfect model performance",
        "correct": false,
        "response": "High bias indicates poor performance due to oversimplification."
      },
      {
        "text": "Data collection errors",
        "correct": false,
        "response": "Bias in ML theory is different from data bias."
      }
    ]
  },
  "cors": {
    "question_text": "What does CORS (Cross-Origin Resource Sharing) control?",
    "topic": "web_development",
    "answers": [
      {
        "text": "Server performance",
        "correct": false,
        "response": "CORS is about security, not performance."
      },
      {
        "text": "Cross-domain requests",
        "correct": true,
        "response": "Correct! CORS controls which domains can access resources.",
        "reward_knowledge": "cors"
      },
      {
        "text": "CSS styling",
        "correct": false,
        "response": "CORS has nothing to do with styling!"
      },
      {
        "text": "Database access",
        "correct": false,
        "response": "CORS is a browser security feature."
      }
    ]
  },
  "jwt": {
    "question_text": "What is a key advantage of JWT (JSON Web Tokens)?",
    "topic": "web_development",
    "answers": [
      {
        "text": "Server must store session",
        "correct": false,
        "response": "JWT is stateless - no server storage!"
      },
      {
        "text": "Stateless authentication",
        "correct": true,
        "response": "Yes! JWTs enable stateless, scalable auth.",
        "reward_knowledge": "jwt"
      },
      {
        "text": "Better encryption",
        "correct": false,
        "response": "JWTs are signed, not necessarily encrypted."
      },
      {
        "text": "Smaller than cookies",
        "correct": false,
        "response": "JWTs are actually larger than session cookies!"
      }
    ]
  },
  "graphql_vs_rest": {
    "type": "multiple_choice",
    "question_text": "What is GraphQL's main advantage over REST?",
    "topic": "web_development",
    "answers": [
      {
        "text": "Clients can request exactly the data they need",
        "correct": true,
        "response": "Correct! GraphQL prevents over-fetching and under-fetching data.",
        "reward_knowledge": "graphql"
      },
      {
        "text": "GraphQL is always faster than REST",
        "correct": false,
        "response": "Performance depends on implementation and use case."
      },
      {
        "text": "GraphQL requires less server code",
        "correct": false,
        "response": "GraphQL servers can be complex to implement."
      },
      {
        "text": "GraphQL works without a network",
        "correct": false,
        "response": "Both require network communication."
      }
    ]
  },
  "websockets": {
    "question_text": "When should you use WebSockets instead of HTTP?",
    "topic": "web_development",
    "answers": [
      {
        "text": "All web applications",
        "correct": false,
        "response": "WebSockets are for specific use cases."
      },
      {
        "text": "Real-time bidirectional communication",
        "correct": true,
        "response": "Yes! WebSockets excel at real-time data.",
        "reward_knowledge": "websockets"
      },
      {
        "text": "File uploads",
        "correct": false,
        "response": "HTTP handles file uploads fine."
      },
      {
        "text": "Static websites",
        "correct": false,
        "response": "Static sites don't need WebSockets!"
      }
    ]
  },
  "cdn": {
    "question_text": "What is the primary purpose of a CDN (Content Delivery Network)?",
    "topic": "networking",
    "answers": [
      {
        "text": "Reduce server costs",
        "correct": false,
        "response": "Cost isn't the primary benefit."
      },
      {
        "text": "Reduce latency via geographic distribution",
        "correct": true,
        "response": "Correct! CDNs cache content closer to users.",
        "reward_knowledge": "cdn"
      },
      {
        "text": "Increase security",
        "correct": false,
        "response": "Security is a side benefit, not the main purpose."
      },
      {
        "text": "Compress files",
        "correct": false,
        "response": "Compression can happen but isn't the main purpose."
      }
    ]
  },
  "nat": {
    "question_text": "What does NAT (Network Address Translation) do?",
    "topic": "networking",
    "answers": [
      {
        "text": "Encrypts traffic",
        "correct": false,
        "response": "NAT doesn't provide encryption."
      },
      {
        "text": "Maps private IPs to public IPs",
        "correct": true,
        "response": "Correct! NAT enables private networks to share public IPs.",
        "reward_knowledge": "nat"
      },
      {
        "text": "Speeds up routing",
        "correct": false,
        "response": "NAT can actually add overhead."
      },
      {
        "text": "Replaces DNS",
        "correct": false,
        "response": "NAT and DNS serve different purposes."
      }
    ]
  },
  "load_balancer_algorithms": {
    "question_text": "Which load balancing algorithm considers server load?",
    "topic": "networking",
    "answers": [
      {
        "text": "Round Robin",
        "correct": false,
        "response": "Round Robin distributes blindly."
      },
      {
        "text": "Random",
        "correct": false,
        "response": "Random doesn't consider load."
      },
      {
        "text": "Least Connections",
        "correct": true,
        "response": "Yes! Least Connections routes to least busy server.",
        "reward_knowledge": "load_balancing"
      },
      {
        "text": "IP Hash",
        "correct": false,
        "response": "IP Hash ensures session affinity, not load balancing."
      }
    ]
  },
  "sql_injection": {
    "type": "yes_no",
    "question_text": "Can SQL injection attacks be prevented by using parameterized queries?",
    "topic": "security",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Parameterized queries prevent SQL injection by separating data from code.",
    "incorrect_response": "Yes - always use parameterized queries to prevent SQL injection."
  },
  "csrf": {
    "question_text": "What does a CSRF token protect against?",
    "topic": "security",
    "answers": [
      {
        "text": "XSS attacks",
        "correct": false,
        "response": "CSRF tokens don't prevent XSS."
      },
      {
        "text": "Cross-Site Request Forgery",
        "correct": true,
        "response": "Correct! CSRF tokens validate request origin.",
        "reward_knowledge": "csrf"
      },
      {
        "text": "SQL injection",
        "correct": false,
        "response": "SQL injection requires different defenses."
      },
      {
        "text": "DDoS attacks",
        "correct": false,
        "response": "CSRF tokens don't help with DDoS."
      }
    ]
  },
  "oauth2": {
    "question_text": "What is OAuth 2.0 primarily used for?",
    "topic": "security",
    "answers": [
      {
        "text": "Password encryption",
        "correct": false,
        "response": "OAuth doesn't handle password encryption."
      },
      {
        "text": "Delegated authorization",
        "correct": true,
        "response": "Yes! OAuth enables third-party access without sharing passwords.",
        "reward_knowledge": "oauth"
      },
      {
        "text": "Data encryption",
        "correct": false,
        "response": "OAuth is for authorization, not encryption."
      },
      {
        "text": "DNS security",
        "correct": false,
        "response": "OAuth isn't related to DNS."
      }
    ]
  },
  "zero_trust": {
    "question_text": "What is the core principle of Zero Trust security?",
    "topic": "security",
    "answers": [
      {
        "text": "Trust the network perimeter",
        "correct": false,
        "response": "Zero Trust doesn't trust the perimeter!"
      },
      {
        "text": "Never trust, always verify",
        "correct": true,
        "response": "Correct! Zero Trust verifies every request.",
        "reward_knowledge": "zero_trust"
      },
      {
        "text": "Trust internal users",
        "correct": false,
        "response": "Zero Trust doesn't assume trust."
      },
      {
        "text": "No authentication needed",
        "correct": false,
        "response": "Zero Trust requires strong authentication!"
      }
    ]
  },
  "virtual_memory": {
    "question_text": "What is the primary benefit of virtual memory?",
    "topic": "systems",
    "answers": [
      {
        "text": "Faster execution",
        "correct": false,
        "response": "Virtual memory can actually slow things down."
      },
      {
        "text": "Isolation and larger address space",
        "correct": true,
        "response": "Correct! Virtual memory provides isolation and apparent memory size.",
        "reward_knowledge": "virtual_memory"
      },
      {
        "text": "Better graphics",
        "correct": false,
        "response": "Graphics use VRAM, different concept."
      },
      {
        "text": "Network performance",
        "correct": false,
        "response": "Virtual memory is about RAM, not networking."
      }
    ]
  },
  "context_switch": {
    "question_text": "What happens during a context switch?",
    "topic": "systems",
    "answers": [
      {
        "text": "CPU is destroyed",
        "correct": false,
        "response": "The CPU isn't damaged!"
      },
      {
        "text": "Process state is saved and restored",
        "correct": true,
        "response": "Yes! Context switches save/restore CPU state.",
        "reward_knowledge": "context_switch"
      },
      {
        "text": "Memory is cleared",
        "correct": false,
        "response": "Memory persists across context switches."
      },
      {
        "text": "New OS is loaded",
        "correct": false,
        "response": "The OS stays the same!"
      }
    ]
  },
  "page_replacement": {
    "question_text": "Which page replacement algorithm is optimal but impractical?",
    "topic": "systems",
    "answers": [
      {
        "text": "FIFO",
        "correct": false,
        "response": "FIFO is practical but not optimal."
      },
      {
        "text": "LRU",
        "correct": false,
        "response": "LRU is practical and good, but not optimal."
      },
      {
        "text": "Optimal (B\u00e9l\u00e1dy's)",
        "correct": true,
        "response": "Correct! Optimal requires knowing the future.",
        "reward_knowledge": "page_replacement"
      },
      {
        "text": "Random",
        "correct": false,
        "response": "Random is definitely not optimal!"
      }
    ]
  },
  "scheduler_types": {
    "question_text": "Which scheduling algorithm can cause starvation?",
    "topic": "systems",
    "answers": [
      {
        "text": "Round Robin",
        "correct": false,
        "response": "Round Robin is fair and prevents starvation."
      },
      {
        "text": "Priority Scheduling",
        "correct": true,
        "response": "Yes! Low-priority processes can starve.",
        "reward_knowledge": "scheduling"
      },
      {
        "text": "FCFS",
        "correct": false,
        "response": "FCFS eventually serves everyone."
      },
      {
        "text": "Lottery Scheduling",
        "correct": false,
        "response": "Lottery scheduling prevents starvation."
      }
    ]
  },
  "eventual_consistency": {
    "question_text": "What does eventual consistency guarantee?",
    "topic": "distributed_systems",
    "answers": [
      {
        "text": "Immediate consistency",
        "correct": false,
        "response": "That's strong consistency!"
      },
      {
        "text": "Consistency after bounded time",
        "correct": true,
        "response": "Correct! Eventually all replicas will be consistent.",
        "reward_knowledge": "eventual_consistency"
      },
      {
        "text": "No consistency guarantee",
        "correct": false,
        "response": "There is a guarantee, just not immediate."
      },
      {
        "text": "Perfect consistency always",
        "correct": false,
        "response": "That's not achievable in distributed systems!"
      }
    ]
  },
  "consensus": {
    "question_text": "What problem does the Paxos algorithm solve?",
    "topic": "distributed_systems",
    "answers": [
      {
        "text": "Sorting",
        "correct": false,
        "response": "Paxos isn't about sorting!"
      },
      {
        "text": "Distributed consensus",
        "correct": true,
        "response": "Yes! Paxos enables agreement in distributed systems.",
        "reward_knowledge": "paxos"
      },
      {
        "text": "Encryption",
        "correct": false,
        "response": "Paxos doesn't handle encryption."
      },
      {
        "text": "Load balancing",
        "correct": false,
        "response": "Paxos is about consensus, not balancing."
      }
    ]
  },
  "vector_clocks": {
    "question_text": "What do vector clocks help determine?",
    "topic": "distributed_systems",
    "answers": [
      {
        "text": "Absolute time",
        "correct": false,
        "response": "Vector clocks don't provide absolute time."
      },
      {
        "text": "Causal ordering of events",
        "correct": true,
        "response": "Correct! Vector clocks track causality.",
        "reward_knowledge": "vector_clocks"
      },
      {
        "text": "Server load",
        "correct": false,
        "response": "Vector clocks aren't about load."
      },
      {
        "text": "Network speed",
        "correct": false,
        "response": "Vector clocks track logical time, not speed."
      }
    ]
  },
  "quorum": {
    "question_text": "In a quorum-based system, what determines consistency?",
    "topic": "distributed_systems",
    "answers": [
      {
        "text": "Single server",
        "correct": false,
        "response": "Quorums need multiple servers!"
      },
      {
        "text": "Read + Write quorum > N",
        "correct": true,
        "response": "Yes! Overlapping quorums ensure consistency.",
        "reward_knowledge": "quorum"
      },
      {
        "text": "All servers must agree",
        "correct": false,
        "response": "Quorums need majority, not all."
      },
      {
        "text": "Random selection",
        "correct": false,
        "response": "Quorums are deterministic!"
      }
    ]
  },
  "infrastructure_as_code": {
    "type": "yes_no",
    "question_text": "Does Infrastructure as Code (IaC) allow you to version control your infrastructure?",
    "topic": "devops",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! IaC treats infrastructure like code - version controlled and reproducible.",
    "incorrect_response": "Yes - IaC lets you track infrastructure changes in version control."
  },
  "monitoring_vs_observability": {
    "question_text": "What is the key difference between monitoring and observability?",
    "topic": "devops",
    "answers": [
      {
        "text": "They're identical",
        "correct": false,
        "response": "They serve different purposes!"
      },
      {
        "text": "Observability enables understanding unknown unknowns",
        "correct": true,
        "response": "Yes! Observability lets you explore unexpected issues.",
        "reward_knowledge": "observability"
      },
      {
        "text": "Monitoring is newer",
        "correct": false,
        "response": "Monitoring came first!"
      },
      {
        "text": "Observability is cheaper",
        "correct": false,
        "response": "Cost isn't the main distinction."
      }
    ]
  },
  "circuit_breaker": {
    "question_text": "What does the circuit breaker pattern prevent?",
    "topic": "devops",
    "answers": [
      {
        "text": "Electrical failures",
        "correct": false,
        "response": "It's a software pattern!"
      },
      {
        "text": "Cascading failures",
        "correct": true,
        "response": "Correct! Circuit breakers stop failure propagation.",
        "reward_knowledge": "circuit_breaker"
      },
      {
        "text": "Security breaches",
        "correct": false,
        "response": "Circuit breakers are about resilience."
      },
      {
        "text": "Memory leaks",
        "correct": false,
        "response": "Not the purpose of circuit breakers."
      }
    ]
  },
  "decorator_pattern": {
    "question_text": "What does the Decorator pattern do?",
    "topic": "design_patterns",
    "answers": [
      {
        "text": "Makes code pretty",
        "correct": false,
        "response": "It's not about aesthetics!"
      },
      {
        "text": "Adds behavior dynamically",
        "correct": true,
        "response": "Yes! Decorators wrap objects with new functionality.",
        "reward_knowledge": "decorator"
      },
      {
        "text": "Removes functionality",
        "correct": false,
        "response": "Decorators add, not remove."
      },
      {
        "text": "Compiles code",
        "correct": false,
        "response": "Decorators are runtime, not compile-time."
      }
    ]
  },
  "adapter_pattern": {
    "question_text": "When should you use the Adapter pattern?",
    "topic": "design_patterns",
    "answers": [
      {
        "text": "When interfaces are compatible",
        "correct": false,
        "response": "Adapters are for incompatible interfaces!"
      },
      {
        "text": "To make incompatible interfaces work together",
        "correct": true,
        "response": "Correct! Adapters bridge incompatible interfaces.",
        "reward_knowledge": "adapter"
      },
      {
        "text": "To speed up code",
        "correct": false,
        "response": "Adapters don't improve performance."
      },
      {
        "text": "For database access",
        "correct": false,
        "response": "Adapters are general-purpose."
      }
    ]
  },
  "command_pattern": {
    "question_text": "What does the Command pattern enable?",
    "topic": "design_patterns",
    "answers": [
      {
        "text": "Faster execution",
        "correct": false,
        "response": "Commands don't improve speed."
      },
      {
        "text": "Encapsulating requests as objects",
        "correct": true,
        "response": "Yes! Commands turn requests into first-class objects.",
        "reward_knowledge": "command"
      },
      {
        "text": "Direct method calls",
        "correct": false,
        "response": "Commands add indirection!"
      },
      {
        "text": "Database operations",
        "correct": false,
        "response": "Commands are general-purpose."
      }
    ]
  },
  "state_pattern": {
    "question_text": "What problem does the State pattern solve?",
    "topic": "design_patterns",
    "answers": [
      {
        "text": "Managing application state cleanly",
        "correct": true,
        "response": "Correct! State pattern avoids large conditionals.",
        "reward_knowledge": "state"
      },
      {
        "text": "Storing data",
        "correct": false,
        "response": "State pattern is about behavior, not storage."
      },
      {
        "text": "Threading",
        "correct": false,
        "response": "Not related to threads."
      },
      {
        "text": "Error handling",
        "correct": false,
        "response": "Not the purpose of State pattern."
      }
    ]
  },
  "indexing": {
    "question_text": "What is a trade-off of adding database indexes?",
    "topic": "databases",
    "answers": [
      {
        "text": "No trade-offs",
        "correct": false,
        "response": "There are always trade-offs!"
      },
      {
        "text": "Faster reads, slower writes",
        "correct": true,
        "response": "Correct! Indexes speed up queries but slow down inserts.",
        "reward_knowledge": "indexing"
      },
      {
        "text": "Slower everything",
        "correct": false,
        "response": "Indexes do help read performance."
      },
      {
        "text": "More storage needed, but no performance impact",
        "correct": false,
        "response": "Indexes affect performance!"
      }
    ]
  },
  "normalization": {
    "type": "yes_no",
    "question_text": "Should you normalize/scale features before training most ML models?",
    "topic": "ai_ml",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Normalization helps models train faster and more reliably.",
    "incorrect_response": "Actually, yes - most models benefit from normalized features."
  },
  "materialized_views": {
    "question_text": "When should you use materialized views?",
    "topic": "databases",
    "answers": [
      {
        "text": "Always, for every query",
        "correct": false,
        "response": "Materialized views have trade-offs!"
      },
      {
        "text": "For expensive queries run frequently",
        "correct": true,
        "response": "Yes! Materialized views cache expensive computations.",
        "reward_knowledge": "materialized_views"
      },
      {
        "text": "To save disk space",
        "correct": false,
        "response": "Materialized views use more space!"
      },
      {
        "text": "Never, they're deprecated",
        "correct": false,
        "response": "Materialized views are still useful!"
      }
    ]
  },
  "write_ahead_log": {
    "question_text": "What is the purpose of a Write-Ahead Log (WAL)?",
    "topic": "databases",
    "answers": [
      {
        "text": "Speed up reads",
        "correct": false,
        "response": "WAL is about durability, not read speed."
      },
      {
        "text": "Ensure durability and recovery",
        "correct": true,
        "response": "Correct! WAL enables crash recovery.",
        "reward_knowledge": "wal"
      },
      {
        "text": "Compress data",
        "correct": false,
        "response": "WAL doesn't compress data."
      },
      {
        "text": "Replicate data",
        "correct": false,
        "response": "Replication uses WAL but isn't its purpose."
      }
    ]
  },
  "closure": {
    "question_text": "What is a closure in programming?",
    "topic": "programming_fundamentals",
    "answers": [
      {
        "text": "A closed loop",
        "correct": false,
        "response": "Not about loops!"
      },
      {
        "text": "Function with access to outer scope",
        "correct": true,
        "response": "Yes! Closures capture their environment.",
        "reward_knowledge": "closure"
      },
      {
        "text": "A finished program",
        "correct": false,
        "response": "That's not what closure means."
      },
      {
        "text": "A type of class",
        "correct": false,
        "response": "Closures are about functions."
      }
    ]
  },
  "lazy_evaluation": {
    "question_text": "What is lazy evaluation?",
    "topic": "programming_fundamentals",
    "answers": [
      {
        "text": "Slow execution",
        "correct": false,
        "response": "Lazy doesn't mean slow!"
      },
      {
        "text": "Computing values only when needed",
        "correct": true,
        "response": "Correct! Lazy evaluation defers computation.",
        "reward_knowledge": "lazy_eval"
      },
      {
        "text": "Caching all results",
        "correct": false,
        "response": "That's memoization, different concept."
      },
      {
        "text": "Parallel execution",
        "correct": false,
        "response": "Lazy evaluation is about deferral."
      }
    ]
  },
  "immutability": {
    "question_text": "What is a benefit of immutable data structures?",
    "topic": "programming_fundamentals",
    "answers": [
      {
        "text": "Use less memory",
        "correct": false,
        "response": "Immutability can use more memory!"
      },
      {
        "text": "Easier to reason about, thread-safe",
        "correct": true,
        "response": "Yes! Immutability prevents many bugs.",
        "reward_knowledge": "immutability"
      },
      {
        "text": "Faster mutations",
        "correct": false,
        "response": "Immutable means no mutations!"
      },
      {
        "text": "Better for I/O",
        "correct": false,
        "response": "Immutability is about state management."
      }
    ]
  },
  "type_inference": {
    "question_text": "What does type inference do?",
    "topic": "programming_fundamentals",
    "answers": [
      {
        "text": "Removes all types",
        "correct": false,
        "response": "Types still exist!"
      },
      {
        "text": "Automatically deduces types",
        "correct": true,
        "response": "Correct! Type inference determines types from context.",
        "reward_knowledge": "type_inference"
      },
      {
        "text": "Makes code slower",
        "correct": false,
        "response": "Inference happens at compile time."
      },
      {
        "text": "Only works with numbers",
        "correct": false,
        "response": "Type inference works with all types."
      }
    ]
  },
  "technical_debt": {
    "question_text": "What is technical debt?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Money owed for tools",
        "correct": false,
        "response": "Not about financial debt!"
      },
      {
        "text": "Cost of suboptimal design choices",
        "correct": true,
        "response": "Yes! Technical debt accumulates from shortcuts.",
        "reward_knowledge": "tech_debt"
      },
      {
        "text": "Literal debt",
        "correct": false,
        "response": "It's a metaphor!"
      },
      {
        "text": "Bug count",
        "correct": false,
        "response": "Bugs are different from tech debt."
      }
    ]
  },
  "cohesion": {
    "question_text": "What does high cohesion mean?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Many responsibilities",
        "correct": false,
        "response": "High cohesion means focused!"
      },
      {
        "text": "Single, well-defined responsibility",
        "correct": true,
        "response": "Correct! High cohesion = focused modules.",
        "reward_knowledge": "cohesion"
      },
      {
        "text": "Lots of dependencies",
        "correct": false,
        "response": "That's high coupling!"
      },
      {
        "text": "Complex code",
        "correct": false,
        "response": "Cohesion is about responsibility."
      }
    ]
  },
  "refactoring": {
    "question_text": "What should refactoring NOT do?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Improve code structure",
        "correct": false,
        "response": "That's the purpose of refactoring!"
      },
      {
        "text": "Change external behavior",
        "correct": true,
        "response": "Correct! Refactoring preserves behavior.",
        "reward_knowledge": "refactoring"
      },
      {
        "text": "Make code more readable",
        "correct": false,
        "response": "Readability is a goal!"
      },
      {
        "text": "Remove duplication",
        "correct": false,
        "response": "DRY is a refactoring goal."
      }
    ]
  },
  "integration_testing": {
    "question_text": "What do integration tests verify?",
    "topic": "testing",
    "answers": [
      {
        "text": "Individual functions",
        "correct": false,
        "response": "That's unit testing!"
      },
      {
        "text": "Components working together",
        "correct": true,
        "response": "Yes! Integration tests verify component interactions.",
        "reward_knowledge": "integration_test"
      },
      {
        "text": "User experience",
        "correct": false,
        "response": "That's UX testing."
      },
      {
        "text": "Performance only",
        "correct": false,
        "response": "Integration tests verify correctness."
      }
    ]
  },
  "property_based_testing": {
    "question_text": "What is property-based testing?",
    "topic": "testing",
    "answers": [
      {
        "text": "Testing object properties",
        "correct": false,
        "response": "Not about object properties!"
      },
      {
        "text": "Testing with generated inputs",
        "correct": true,
        "response": "Yes! Property tests use random inputs to verify invariants.",
        "reward_knowledge": "property_test"
      },
      {
        "text": "Testing CSS properties",
        "correct": false,
        "response": "Nothing to do with CSS!"
      },
      {
        "text": "Manual testing",
        "correct": false,
        "response": "Property tests are automated."
      }
    ]
  },
  "mutation_testing": {
    "question_text": "What does mutation testing measure?",
    "topic": "testing",
    "answers": [
      {
        "text": "Code changes over time",
        "correct": false,
        "response": "Not about version control!"
      },
      {
        "text": "Test suite effectiveness",
        "correct": true,
        "response": "Yes! Mutation testing finds weak tests.",
        "reward_knowledge": "mutation_test"
      },
      {
        "text": "Database mutations",
        "correct": false,
        "response": "Not about databases!"
      },
      {
        "text": "Performance changes",
        "correct": false,
        "response": "Mutation testing is about correctness."
      }
    ]
  },
  "canary_deployment": {
    "question_text": "What is canary deployment?",
    "topic": "devops",
    "answers": [
      {
        "text": "Deploy to subset of users first",
        "correct": true,
        "response": "Correct\\! Canary deployments gradually roll out to a small percentage of users first, monitoring for issues before full rollout. This reduces blast radius of bugs. Named after coal mine canaries\\!",
        "reward_knowledge": "canary_deployment"
      },
      {
        "text": "Deploy only at night",
        "correct": false,
        "response": "Timing isn't the key aspect. Canary deploys to a subset of users first to catch issues early."
      },
      {
        "text": "Deploy to yellow servers",
        "correct": false,
        "response": "Not about server colors\\! Canary means releasing to a small group first to test changes safely."
      },
      {
        "text": "Same as blue-green",
        "correct": false,
        "response": "Different\\! Blue-green switches all traffic at once. Canary gradually increases traffic to the new version."
      }
    ]
  },
  "container_security": {
    "question_text": "What is a key security best practice for container images?",
    "topic": "devops",
    "answers": [
      {
        "text": "Run as root always",
        "correct": false,
        "response": "Never run as root\\! Use non-root users to minimize damage if container is compromised."
      },
      {
        "text": "Use minimal base images and scan for vulnerabilities",
        "correct": true,
        "response": "Correct\\! Use slim base images (Alpine, distroless), scan with tools like Trivy, update dependencies regularly, and never include secrets. Less software = smaller attack surface\\!",
        "reward_knowledge": "container_security"
      },
      {
        "text": "Include all tools for debugging",
        "correct": false,
        "response": "Minimize tools in production images\\! Each tool is a potential vulnerability. Use separate debug images if needed."
      },
      {
        "text": "Hardcode secrets in images",
        "correct": false,
        "response": "Never hardcode secrets\\! Use environment variables, secret managers, or mounted volumes."
      }
    ]
  },
  "four_golden_signals": {
    "question_text": "What are the 'Four Golden Signals' of monitoring?",
    "topic": "devops",
    "answers": [
      {
        "text": "Latency, Traffic, Errors, Saturation",
        "correct": true,
        "response": "Correct\\! Google's SRE book defines these: Latency (response time), Traffic (demand), Errors (failed requests), Saturation (resource usage). Monitor these to understand system health\\!",
        "reward_knowledge": "golden_signals"
      },
      {
        "text": "CPU, Memory, Disk, Network",
        "correct": false,
        "response": "Those are infrastructure metrics. Golden signals focus on user-facing metrics: latency, traffic, errors, saturation."
      },
      {
        "text": "Logs, Metrics, Traces, Alerts",
        "correct": false,
        "response": "Those are observability pillars. Golden signals are specific metrics: latency, traffic, errors, saturation."
      },
      {
        "text": "Uptime, Downtime, SLA, SLO",
        "correct": false,
        "response": "Those are reliability metrics. Golden signals are: latency, traffic, errors, saturation."
      }
    ]
  },
  "rolling_update": {
    "question_text": "How does a rolling update work?",
    "topic": "devops",
    "answers": [
      {
        "text": "Update all servers at once",
        "correct": false,
        "response": "That would cause downtime\\! Rolling updates incrementally replace instances."
      },
      {
        "text": "Gradually replace old instances with new ones",
        "correct": true,
        "response": "Correct\\! Rolling updates replace instances one by one (or in small batches), maintaining availability. If issues arise, you can pause or roll back. Kubernetes and ECS support this natively.",
        "reward_knowledge": "rolling_update"
      },
      {
        "text": "Only roll logs, not code",
        "correct": false,
        "response": "Not about logs\\! Rolling update means gradually replacing old application versions with new ones."
      },
      {
        "text": "Update database only",
        "correct": false,
        "response": "Rolling updates apply to application instances, not just databases."
      }
    ]
  },
  "terraform_state": {
    "question_text": "Why is Terraform state important?",
    "topic": "devops",
    "answers": [
      {
        "text": "It's not needed",
        "correct": false,
        "response": "State is essential\\! Terraform needs it to map configuration to real resources."
      },
      {
        "text": "Tracks real infrastructure to detect drift",
        "correct": true,
        "response": "Correct\\! State maps your configuration to real resources, enabling drift detection, incremental changes, and collaboration. Store it remotely (S3, Terraform Cloud) with locking to prevent corruption\\!",
        "reward_knowledge": "terraform"
      },
      {
        "text": "Only for local testing",
        "correct": false,
        "response": "State is critical for production\\! Remote state enables team collaboration and prevents conflicts."
      },
      {
        "text": "Can be deleted safely anytime",
        "correct": false,
        "response": "Never delete state\\! You'll lose the mapping to real resources. Back it up carefully."
      }
    ]
  },
  "api_pagination": {
    "question_text": "What's the advantage of cursor-based over offset-based pagination?",
    "topic": "system_design",
    "answers": [
      {
        "text": "Faster for large datasets, handles changes correctly",
        "correct": true,
        "response": "Correct\\! Cursor-based pagination uses a pointer (e.g., last ID) so performance stays constant. Offset pagination gets slower with high offsets and breaks if data changes. Cursors are stable\\!",
        "reward_knowledge": "api_pagination"
      },
      {
        "text": "Offset is always better",
        "correct": false,
        "response": "Offset is simpler but slower at scale. Offset 1000000 requires skipping a million rows\\!"
      },
      {
        "text": "They're identical",
        "correct": false,
        "response": "Very different\\! Cursors maintain position even as data changes. Offsets can skip or duplicate items."
      },
      {
        "text": "Cursors only work with REST",
        "correct": false,
        "response": "Cursors work with any API style - REST, GraphQL, gRPC. It's a pagination strategy."
      }
    ]
  },
  "idempotency": {
    "question_text": "Why is idempotency important in distributed systems?",
    "topic": "system_design",
    "answers": [
      {
        "text": "Retry safety - same request can be sent multiple times safely",
        "correct": true,
        "response": "Correct\\! Networks are unreliable. Idempotency means retrying a failed request won't cause duplicates. Use idempotency keys, PUT instead of POST, or natural idempotence of operations.",
        "reward_knowledge": "idempotency"
      },
      {
        "text": "Makes systems faster",
        "correct": false,
        "response": "Not about speed. Idempotency ensures safety when requests are retried due to timeouts or failures."
      },
      {
        "text": "Reduces server load",
        "correct": false,
        "response": "Load isn't the key benefit. It's about handling duplicate requests correctly without side effects."
      },
      {
        "text": "Only needed for databases",
        "correct": false,
        "response": "All distributed operations need idempotency\\! APIs, message queues, payment systems, etc."
      }
    ]
  },
  "event_driven": {
    "question_text": "What's a key benefit of event-driven architecture?",
    "topic": "system_design",
    "answers": [
      {
        "text": "Decoupling and asynchronous processing",
        "correct": true,
        "response": "Correct\\! Producers emit events without knowing consumers. Consumers react independently. Great for complex workflows and scaling. Examples: order placed \u2192 inventory, email, analytics all react.",
        "reward_knowledge": "event_driven"
      },
      {
        "text": "Simpler than synchronous calls",
        "correct": false,
        "response": "Actually more complex\\! Event-driven adds debugging challenges, eventual consistency, ordering issues. But gains flexibility."
      },
      {
        "text": "Faster than REST APIs",
        "correct": false,
        "response": "Not necessarily faster. Events add latency from queues. The benefit is decoupling, not raw speed."
      },
      {
        "text": "Eliminates need for databases",
        "correct": false,
        "response": "Still need databases\\! Event sourcing stores events as truth, but you often materialize views."
      }
    ]
  },
  "retry_backoff": {
    "question_text": "Why use exponential backoff for retries?",
    "topic": "system_design",
    "answers": [
      {
        "text": "Prevents thundering herd, gives system time to recover",
        "correct": true,
        "response": "Correct\\! If all clients retry immediately, you overwhelm the recovering system. Exponential backoff (1s, 2s, 4s, 8s...) with jitter spaces out retries. Protects both client and server\\!",
        "reward_knowledge": "retry_patterns"
      },
      {
        "text": "Makes retries faster",
        "correct": false,
        "response": "Backoff actually waits longer between retries\\! The goal is giving systems time to recover."
      },
      {
        "text": "Prevents all errors",
        "correct": false,
        "response": "Can't prevent errors. Backoff helps manage retry storms when systems are already struggling."
      },
      {
        "text": "Only needed for networks",
        "correct": false,
        "response": "Useful anywhere with failures: APIs, databases, external services, batch jobs."
      }
    ]
  },
  "saga_pattern": {
    "question_text": "What is the Saga pattern in microservices?",
    "topic": "system_design",
    "answers": [
      {
        "text": "Manages distributed transactions with compensating actions",
        "correct": true,
        "response": "Correct\\! Sagas break long transactions into steps, each with a compensating action for rollback. Example: book hotel \u2192 charge card \u2192 send confirmation. If charge fails, cancel hotel. No 2PC needed\\!",
        "reward_knowledge": "saga_pattern"
      },
      {
        "text": "A type of database",
        "correct": false,
        "response": "Not a database\\! Saga is a pattern for coordinating multi-service transactions without distributed locks."
      },
      {
        "text": "Same as two-phase commit",
        "correct": false,
        "response": "Different\\! 2PC locks resources. Sagas use eventual consistency and compensating actions for rollback."
      },
      {
        "text": "Only for event sourcing",
        "correct": false,
        "response": "Sagas work with any architecture. Can be choreographed (events) or orchestrated (coordinator)."
      }
    ]
  },
  "big_theta_notation": {
    "question_text": "What does Big-Theta (\u0398) notation represent?",
    "topic": "theory",
    "answers": [
      {
        "text": "Tight bound - both upper and lower",
        "correct": true,
        "response": "Correct\\! \u0398(n) means the function grows exactly at rate n - both upper and lower bounded. O(n) is upper bound only, \u03a9(n) is lower bound only. \u0398 is most precise\\!",
        "reward_knowledge": "complexity_notation"
      },
      {
        "text": "Worst case only",
        "correct": false,
        "response": "That's Big-O\\! \u0398 (theta) gives a tight bound - the function grows exactly at that rate, not just at most."
      },
      {
        "text": "Best case only",
        "correct": false,
        "response": "That's Big-Omega (\u03a9)\\! \u0398 bounds both directions - the function grows exactly at that rate."
      },
      {
        "text": "Average case",
        "correct": false,
        "response": "Asymptotic notation describes growth rates, not probabilistic cases. \u0398 means tight bound (exact growth)."
      }
    ]
  },
  "np_complete": {
    "question_text": "What makes a problem NP-complete?",
    "topic": "theory",
    "answers": [
      {
        "text": "In NP and all NP problems reduce to it",
        "correct": true,
        "response": "Correct\\! NP-complete problems are the hardest in NP - if you solve one efficiently, you solve all NP problems\\! SAT, TSP, Graph Coloring are classics. No polynomial algorithm known.",
        "reward_knowledge": "np_complete"
      },
      {
        "text": "Can't be solved by computers",
        "correct": false,
        "response": "NP-complete problems CAN be solved, just not efficiently (no known polynomial algorithm). They're solvable but slow\\!"
      },
      {
        "text": "Same as undecidable",
        "correct": false,
        "response": "Different\\! Undecidable (like halting problem) has NO algorithm. NP-complete has algorithms, just not efficient ones."
      },
      {
        "text": "Easier than NP problems",
        "correct": false,
        "response": "Opposite\\! NP-complete problems are the HARDEST in NP. All other NP problems reduce to them."
      }
    ]
  },
  "context_free_grammar": {
    "question_text": "What can context-free grammars describe that regular expressions cannot?",
    "topic": "theory",
    "answers": [
      {
        "text": "Nested structures like balanced parentheses",
        "correct": true,
        "response": "Correct\\! CFGs can count and match nested structures. RegEx can't match {a^n b^n} (equal a's and b's). That's why parsers use CFGs for code, HTML, etc\\!",
        "reward_knowledge": "formal_languages"
      },
      {
        "text": "Regular expressions are more powerful",
        "correct": false,
        "response": "Opposite\\! CFGs are strictly more powerful than regular expressions in the Chomsky hierarchy."
      },
      {
        "text": "They're equally powerful",
        "correct": false,
        "response": "CFGs are more powerful\\! They can handle nested structures that RegEx cannot."
      },
      {
        "text": "Nothing - CFGs are weaker",
        "correct": false,
        "response": "CFGs are MORE powerful\\! They can describe nested/recursive structures that regular languages can't."
      }
    ]
  },
  "master_theorem": {
    "question_text": "What does the Master Theorem help analyze?",
    "topic": "theory",
    "answers": [
      {
        "text": "Recurrence relations for divide-and-conquer",
        "correct": true,
        "response": "Correct\\! Master Theorem gives Big-O for recurrences like T(n) = aT(n/b) + f(n). Instantly analyze merge sort, binary search, etc without solving\\!",
        "reward_knowledge": "master_theorem"
      },
      {
        "text": "Graph algorithms only",
        "correct": false,
        "response": "Master Theorem analyzes divide-and-conquer recurrences - any recursive algorithm that splits into subproblems."
      },
      {
        "text": "Dynamic programming problems",
        "correct": false,
        "response": "Master Theorem is for divide-and-conquer, not DP. DP has overlapping subproblems; D&C splits independently."
      },
      {
        "text": "Database query performance",
        "correct": false,
        "response": "Master Theorem analyzes recursive algorithm complexity, not database queries."
      }
    ]
  },
  "supervised_learning": {
    "type": "multiple_choice",
    "question_text": "What is supervised learning?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Learning from labeled data",
        "correct": true,
        "response": "Correct! Supervised learning trains on labeled examples.",
        "reward_knowledge": "ml_basics"
      },
      {
        "text": "Learning without any data",
        "correct": false,
        "response": "ML always requires data. You're thinking of something else."
      },
      {
        "text": "Learning from unlabeled data only",
        "correct": false,
        "response": "That's unsupervised learning, not supervised."
      },
      {
        "text": "Learning by trial and error",
        "correct": false,
        "response": "That's reinforcement learning, not supervised."
      }
    ]
  },
  "overfitting_definition": {
    "type": "multiple_choice",
    "question_text": "What is overfitting in machine learning?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Model performs well on training data but poorly on new data",
        "correct": true,
        "response": "Correct! Overfitting means the model memorized training data instead of learning patterns.",
        "reward_knowledge": "overfitting"
      },
      {
        "text": "Model performs poorly on all data",
        "correct": false,
        "response": "That's underfitting, not overfitting."
      },
      {
        "text": "Model trains too slowly",
        "correct": false,
        "response": "Overfitting is about generalization, not training speed."
      },
      {
        "text": "Model uses too much memory",
        "correct": false,
        "response": "Overfitting is about generalization, not memory usage."
      }
    ]
  },
  "train_test_split": {
    "type": "yes_no",
    "question_text": "Should you evaluate your ML model on the same data you trained it on?",
    "topic": "ai_ml",
    "correct_answer": "no|false|n",
    "correct_response": "Correct! Always use separate test data to evaluate generalization.",
    "incorrect_response": "No - you need separate test data to measure how well the model generalizes."
  },
  "gradient_descent_purpose": {
    "type": "short_answer",
    "question_text": "What algorithm is commonly used to minimize the loss function in neural networks?",
    "topic": "ai_ml",
    "correct_answer": "gradient descent|SGD|stochastic gradient descent|backpropagation|backprop",
    "match_type": "exact",
    "correct_response": "Correct! Gradient descent iteratively adjusts weights to minimize loss.",
    "incorrect_response": "Think about how neural networks optimize their weights during training.",
    "reward_knowledge": "optimization"
  },
  "neural_network_layer": {
    "type": "multiple_choice",
    "question_text": "What is a layer in a neural network?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "A collection of neurons/nodes",
        "correct": true,
        "response": "Correct! Layers contain neurons that process information.",
        "reward_knowledge": "neural_networks"
      },
      {
        "text": "A training epoch",
        "correct": false,
        "response": "An epoch is a full pass through training data, not a layer."
      },
      {
        "text": "A type of activation function",
        "correct": false,
        "response": "Activation functions are used within layers, not layers themselves."
      },
      {
        "text": "A data preprocessing step",
        "correct": false,
        "response": "Preprocessing happens before the neural network."
      }
    ]
  },
  "classification_vs_regression": {
    "type": "multiple_choice",
    "question_text": "What's the difference between classification and regression?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Classification predicts categories, regression predicts numbers",
        "correct": true,
        "response": "Correct! Classification outputs discrete classes, regression outputs continuous values."
      },
      {
        "text": "Classification is faster than regression",
        "correct": false,
        "response": "Speed depends on the algorithm, not the task type."
      },
      {
        "text": "Regression only works on images",
        "correct": false,
        "response": "Both work on various data types, not just images."
      },
      {
        "text": "They are the same thing",
        "correct": false,
        "response": "They're different types of ML tasks with different outputs."
      }
    ]
  },
  "feature_engineering": {
    "type": "multiple_choice",
    "question_text": "What is feature engineering?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Creating useful input variables from raw data",
        "correct": true,
        "response": "Correct! Feature engineering transforms raw data into meaningful inputs.",
        "reward_knowledge": "features"
      },
      {
        "text": "Designing the neural network architecture",
        "correct": false,
        "response": "That's model architecture, not feature engineering."
      },
      {
        "text": "Removing bugs from the code",
        "correct": false,
        "response": "That's debugging, not feature engineering."
      },
      {
        "text": "Collecting more training data",
        "correct": false,
        "response": "That's data collection, not feature engineering."
      }
    ]
  },
  "cross_validation": {
    "type": "short_answer",
    "question_text": "What technique splits data into k folds for robust model evaluation?",
    "topic": "ai_ml",
    "correct_answer": "cross-validation|k-fold|k fold|cross validation|k-fold cross-validation",
    "match_type": "exact",
    "correct_response": "Correct! K-fold cross-validation provides more reliable performance estimates.",
    "incorrect_response": "Think about validation techniques that use multiple train/test splits."
  },
  "confusion_matrix": {
    "type": "multiple_choice",
    "question_text": "What does a confusion matrix show?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "True positives, false positives, true negatives, false negatives",
        "correct": true,
        "response": "Correct! It shows all four outcomes of a binary classifier.",
        "reward_knowledge": "evaluation_metrics"
      },
      {
        "text": "The training loss over time",
        "correct": false,
        "response": "That's a training curve, not a confusion matrix."
      },
      {
        "text": "Feature importance scores",
        "correct": false,
        "response": "That's feature importance analysis, not a confusion matrix."
      },
      {
        "text": "The network architecture",
        "correct": false,
        "response": "That would be a model diagram, not a confusion matrix."
      }
    ]
  },
  "precision_vs_recall": {
    "type": "multiple_choice",
    "question_text": "What does precision measure in classification?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "What fraction of positive predictions were correct",
        "correct": true,
        "response": "Correct! Precision = TP / (TP + FP).",
        "reward_knowledge": "precision_recall"
      },
      {
        "text": "What fraction of actual positives were found",
        "correct": false,
        "response": "That's recall, not precision."
      },
      {
        "text": "Overall accuracy of the model",
        "correct": false,
        "response": "That's accuracy, not precision."
      },
      {
        "text": "The confidence of predictions",
        "correct": false,
        "response": "That's prediction confidence, not precision."
      }
    ]
  },
  "batch_size": {
    "type": "multiple_choice",
    "question_text": "What is batch size in neural network training?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Number of samples processed before updating weights",
        "correct": true,
        "response": "Correct! Batch size determines how many samples are used per gradient update."
      },
      {
        "text": "Total number of training samples",
        "correct": false,
        "response": "That's the dataset size, not batch size."
      },
      {
        "text": "Number of layers in the network",
        "correct": false,
        "response": "That's network depth, not batch size."
      },
      {
        "text": "Number of training epochs",
        "correct": false,
        "response": "That's the number of complete passes through data, not batch size."
      }
    ]
  },
  "activation_function": {
    "type": "short_answer",
    "question_text": "Name a common activation function used in neural networks.",
    "topic": "ai_ml",
    "correct_answer": "ReLU|sigmoid|tanh|softmax|relu|Sigmoid|Tanh|Softmax",
    "match_type": "exact",
    "correct_response": "Correct! That's a commonly used activation function.",
    "incorrect_response": "Try ReLU, sigmoid, tanh, or softmax."
  },
  "learning_rate": {
    "type": "multiple_choice",
    "question_text": "What happens if the learning rate is too high?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Training may not converge or diverge",
        "correct": true,
        "response": "Correct! Too high a learning rate causes unstable training."
      },
      {
        "text": "Training will be perfectly optimized",
        "correct": false,
        "response": "Too high actually destabilizes training."
      },
      {
        "text": "The model will underfit",
        "correct": false,
        "response": "Underfitting is more about model capacity, not learning rate."
      },
      {
        "text": "Memory usage will increase",
        "correct": false,
        "response": "Learning rate doesn't significantly affect memory usage."
      }
    ]
  },
  "epoch_definition": {
    "type": "short_answer",
    "question_text": "What is one complete pass through the entire training dataset called?",
    "topic": "ai_ml",
    "correct_answer": "epoch|training epoch|iteration",
    "match_type": "exact",
    "correct_response": "Correct! An epoch is one full pass through all training data.",
    "incorrect_response": "Think about the term for a complete training cycle through all data."
  },
  "dropout_technique": {
    "type": "multiple_choice",
    "question_text": "What is dropout in neural networks?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Randomly deactivating neurons during training",
        "correct": true,
        "response": "Correct! Dropout prevents overfitting by randomly ignoring neurons.",
        "reward_knowledge": "regularization"
      },
      {
        "text": "Removing bad training samples",
        "correct": false,
        "response": "That's data cleaning, not dropout."
      },
      {
        "text": "Stopping training early",
        "correct": false,
        "response": "That's early stopping, not dropout."
      },
      {
        "text": "Reducing the learning rate",
        "correct": false,
        "response": "That's learning rate decay, not dropout."
      }
    ]
  },
  "reinforcement_learning": {
    "type": "multiple_choice",
    "question_text": "What is reinforcement learning?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Learning through rewards and penalties",
        "correct": true,
        "response": "Correct! RL agents learn by receiving rewards for good actions.",
        "reward_knowledge": "reinforcement_learning"
      },
      {
        "text": "Learning from labeled examples",
        "correct": false,
        "response": "That's supervised learning, not reinforcement learning."
      },
      {
        "text": "Learning patterns in unlabeled data",
        "correct": false,
        "response": "That's unsupervised learning, not reinforcement learning."
      },
      {
        "text": "Strengthening neural connections",
        "correct": false,
        "response": "While neural, the term refers to the learning paradigm, not neurology."
      }
    ]
  },
  "decision_tree": {
    "type": "yes_no",
    "question_text": "Can decision trees handle both classification and regression tasks?",
    "topic": "ai_ml",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Decision trees work for both classification and regression.",
    "incorrect_response": "Actually, decision trees are versatile and handle both tasks."
  },
  "ensemble_learning": {
    "type": "multiple_choice",
    "question_text": "What is ensemble learning?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Combining multiple models for better predictions",
        "correct": true,
        "response": "Correct! Ensembles like Random Forests combine many models.",
        "reward_knowledge": "ensemble"
      },
      {
        "text": "Training one very large model",
        "correct": false,
        "response": "That's the opposite - ensemble uses multiple smaller models."
      },
      {
        "text": "Using all available features",
        "correct": false,
        "response": "That's about feature selection, not ensemble learning."
      },
      {
        "text": "Training in parallel on multiple GPUs",
        "correct": false,
        "response": "That's distributed training, not ensemble learning."
      }
    ]
  },
  "data_augmentation": {
    "type": "multiple_choice",
    "question_text": "Why use data augmentation in machine learning?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "To artificially increase training data variety",
        "correct": true,
        "response": "Correct! Augmentation creates variations to improve generalization."
      },
      {
        "text": "To reduce training time",
        "correct": false,
        "response": "Augmentation actually increases training time."
      },
      {
        "text": "To compress the model",
        "correct": false,
        "response": "That's model compression, not data augmentation."
      },
      {
        "text": "To visualize the data",
        "correct": false,
        "response": "That's data visualization, not augmentation."
      }
    ]
  },
  "transfer_learning": {
    "type": "multiple_choice",
    "question_text": "What is transfer learning?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Using a pre-trained model as a starting point",
        "correct": true,
        "response": "Correct! Transfer learning leverages knowledge from previous tasks.",
        "reward_knowledge": "transfer_learning"
      },
      {
        "text": "Moving data between servers",
        "correct": false,
        "response": "That's data transfer, not transfer learning."
      },
      {
        "text": "Converting between model formats",
        "correct": false,
        "response": "That's model conversion, not transfer learning."
      },
      {
        "text": "Teaching one model to another",
        "correct": false,
        "response": "That's knowledge distillation, not quite transfer learning."
      }
    ]
  },
  "loss_function": {
    "type": "multiple_choice",
    "question_text": "What does the loss function measure?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "How far predictions are from actual values",
        "correct": true,
        "response": "Correct! Loss quantifies prediction error during training."
      },
      {
        "text": "How fast the model trains",
        "correct": false,
        "response": "That's training speed, not loss."
      },
      {
        "text": "How much memory the model uses",
        "correct": false,
        "response": "That's memory usage, not loss."
      },
      {
        "text": "How many parameters the model has",
        "correct": false,
        "response": "That's model size, not loss."
      }
    ]
  },
  "clustering": {
    "type": "short_answer",
    "question_text": "What type of learning groups similar data points together without labels?",
    "topic": "ai_ml",
    "correct_answer": "unsupervised|unsupervised learning|clustering",
    "match_type": "exact",
    "correct_response": "Correct! Unsupervised learning/clustering finds patterns without labels.",
    "incorrect_response": "Think about learning without labeled training data.",
    "reward_knowledge": "unsupervised"
  },
  "validation_set": {
    "type": "multiple_choice",
    "question_text": "What is the purpose of a validation set?",
    "topic": "ai_ml",
    "answers": [
      {
        "text": "Tune hyperparameters without touching test data",
        "correct": true,
        "response": "Correct! Validation helps tune without biasing the test evaluation."
      },
      {
        "text": "Replace the training set",
        "correct": false,
        "response": "Validation supplements training, doesn't replace it."
      },
      {
        "text": "Make the model train faster",
        "correct": false,
        "response": "Validation is for evaluation, not speed."
      },
      {
        "text": "Store extra training samples",
        "correct": false,
        "response": "It's used during training for monitoring, not storage."
      }
    ]
  },
  "docker_purpose": {
    "type": "multiple_choice",
    "question_text": "What is the primary benefit of using Docker containers?",
    "topic": "devops",
    "answers": [
      {
        "text": "Consistent environments across development and production",
        "correct": true,
        "response": "Correct! Docker ensures 'it works on my machine' works everywhere.",
        "reward_knowledge": "containerization"
      },
      {
        "text": "Faster code execution than native",
        "correct": false,
        "response": "Containers have slight overhead, not performance gains."
      },
      {
        "text": "Automatic code optimization",
        "correct": false,
        "response": "Docker packages code, doesn't optimize it."
      },
      {
        "text": "Built-in security scanning",
        "correct": false,
        "response": "Security scanning is separate from containerization."
      }
    ]
  },
  "ci_cd_definition": {
    "type": "multiple_choice",
    "question_text": "What does CI/CD stand for?",
    "topic": "devops",
    "answers": [
      {
        "text": "Continuous Integration / Continuous Deployment",
        "correct": true,
        "response": "Correct! CI/CD automates testing and deployment.",
        "reward_knowledge": "cicd"
      },
      {
        "text": "Code Integration / Code Distribution",
        "correct": false,
        "response": "Close, but not the standard terminology."
      },
      {
        "text": "Container Integration / Container Delivery",
        "correct": false,
        "response": "CI/CD is broader than just containers."
      },
      {
        "text": "Compiled Infrastructure / Compiled Deployment",
        "correct": false,
        "response": "Not about compilation."
      }
    ]
  },
  "microservices_benefit": {
    "type": "multiple_choice",
    "question_text": "What is a key advantage of microservices architecture?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Independent scaling and deployment of services",
        "correct": true,
        "response": "Correct! Each microservice can scale and deploy independently.",
        "reward_knowledge": "architecture"
      },
      {
        "text": "Simpler codebase than monoliths",
        "correct": false,
        "response": "Microservices add distributed systems complexity."
      },
      {
        "text": "No need for inter-service communication",
        "correct": false,
        "response": "Services must communicate, adding complexity."
      },
      {
        "text": "Eliminates all bugs",
        "correct": false,
        "response": "Architecture doesn't eliminate bugs."
      }
    ]
  },
  "rest_idempotent": {
    "type": "short_answer",
    "question_text": "Which HTTP method is idempotent: GET, POST, or both?",
    "topic": "web_development",
    "correct_answer": "GET|get|Get",
    "match_type": "exact",
    "correct_response": "Correct! GET is idempotent - multiple identical requests have the same effect.",
    "incorrect_response": "GET is idempotent (same result every time), POST is not (creates new resources).",
    "reward_knowledge": "rest_api"
  },
  "git_merge_vs_rebase": {
    "type": "multiple_choice",
    "question_text": "What's the main difference between git merge and git rebase?",
    "topic": "devops",
    "answers": [
      {
        "text": "Rebase rewrites commit history, merge preserves it",
        "correct": true,
        "response": "Correct! Rebase creates linear history, merge preserves branch history.",
        "reward_knowledge": "git_workflows"
      },
      {
        "text": "Merge is faster than rebase",
        "correct": false,
        "response": "Performance isn't the key difference."
      },
      {
        "text": "Rebase only works on main branch",
        "correct": false,
        "response": "Rebase works on any branch."
      },
      {
        "text": "Merge requires pull requests",
        "correct": false,
        "response": "Pull requests are a workflow choice, not a merge requirement."
      }
    ]
  },
  "kubernetes_purpose": {
    "type": "multiple_choice",
    "question_text": "What does Kubernetes primarily do?",
    "topic": "devops",
    "answers": [
      {
        "text": "Orchestrates and manages containerized applications",
        "correct": true,
        "response": "Correct! Kubernetes automates deployment, scaling, and management of containers.",
        "reward_knowledge": "kubernetes"
      },
      {
        "text": "Writes Docker files automatically",
        "correct": false,
        "response": "Kubernetes uses existing containers, doesn't create them."
      },
      {
        "text": "Compiles code faster",
        "correct": false,
        "response": "Kubernetes is about deployment, not compilation."
      },
      {
        "text": "Monitors network traffic only",
        "correct": false,
        "response": "Monitoring is one feature, not the primary purpose."
      }
    ]
  },
  "observability_vs_monitoring": {
    "type": "multiple_choice",
    "question_text": "How does observability differ from monitoring?",
    "topic": "devops",
    "answers": [
      {
        "text": "Observability lets you ask new questions without predicting them",
        "correct": true,
        "response": "Correct! Monitoring tracks known issues, observability explores unknown problems.",
        "reward_knowledge": "observability"
      },
      {
        "text": "Observability is just a buzzword for monitoring",
        "correct": false,
        "response": "They're related but meaningfully different concepts."
      },
      {
        "text": "Monitoring is more advanced than observability",
        "correct": false,
        "response": "Observability is actually the broader concept."
      },
      {
        "text": "Observability only works in cloud environments",
        "correct": false,
        "response": "Observability applies to any system."
      }
    ]
  },
  "twelve_factor_app": {
    "type": "short_answer",
    "question_text": "What methodology defines 12 best practices for building cloud-native apps?",
    "topic": "software_engineering",
    "correct_answer": "twelve-factor|12-factor|twelve factor|12 factor|the twelve-factor app|12factor",
    "match_type": "exact",
    "correct_response": "Correct! The Twelve-Factor App methodology guides modern cloud app development.",
    "incorrect_response": "Think about a numbered methodology for cloud-native applications.",
    "reward_knowledge": "cloud_native"
  },
  "container_vs_vm": {
    "type": "multiple_choice",
    "question_text": "What's the main difference between containers and virtual machines?",
    "topic": "devops",
    "answers": [
      {
        "text": "Containers share the host OS kernel, VMs include full OS",
        "correct": true,
        "response": "Correct! Containers are lighter weight by sharing the kernel.",
        "reward_knowledge": "virtualization"
      },
      {
        "text": "VMs are always faster than containers",
        "correct": false,
        "response": "Containers typically start faster due to less overhead."
      },
      {
        "text": "Containers cannot run Linux applications",
        "correct": false,
        "response": "Most containers run Linux applications!"
      },
      {
        "text": "VMs require Docker to run",
        "correct": false,
        "response": "VMs predate Docker and don't require it."
      }
    ]
  },
  "serverless_computing": {
    "type": "multiple_choice",
    "question_text": "What does 'serverless' computing mean?",
    "topic": "devops",
    "answers": [
      {
        "text": "You don't manage servers, the cloud provider does",
        "correct": true,
        "response": "Correct! Serverless means no server management, not no servers.",
        "reward_knowledge": "serverless"
      },
      {
        "text": "Applications run without any servers",
        "correct": false,
        "response": "Servers still exist, you just don't manage them."
      },
      {
        "text": "It's only for static websites",
        "correct": false,
        "response": "Serverless handles dynamic backend logic too."
      },
      {
        "text": "It's always cheaper than traditional hosting",
        "correct": false,
        "response": "Cost depends on usage patterns."
      }
    ]
  },
  "event_driven_architecture": {
    "type": "yes_no",
    "question_text": "In event-driven architecture, do services communicate through asynchronous events?",
    "topic": "software_engineering",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Event-driven systems use async events for loose coupling.",
    "incorrect_response": "Yes - event-driven architecture uses asynchronous event messages for communication."
  },
  "cdn_purpose": {
    "type": "short_answer",
    "question_text": "What does CDN stand for?",
    "topic": "networking",
    "correct_answer": "Content Delivery Network|content delivery network|CDN",
    "match_type": "exact",
    "correct_response": "Correct! CDNs cache content closer to users for faster delivery.",
    "incorrect_response": "Think about networks that deliver content from distributed locations.",
    "reward_knowledge": "cdn"
  },
  "load_balancer_purpose": {
    "type": "multiple_choice",
    "question_text": "What is the primary purpose of a load balancer?",
    "topic": "distributed_systems",
    "answers": [
      {
        "text": "Distribute incoming requests across multiple servers",
        "correct": true,
        "response": "Correct! Load balancers improve availability and handle more traffic.",
        "reward_knowledge": "load_balancing"
      },
      {
        "text": "Reduce server electricity costs",
        "correct": false,
        "response": "It's about traffic distribution, not power usage."
      },
      {
        "text": "Encrypt all network traffic",
        "correct": false,
        "response": "Encryption is separate from load balancing."
      },
      {
        "text": "Store database backups",
        "correct": false,
        "response": "That's backup systems, not load balancers."
      }
    ]
  },
  "feature_flags": {
    "type": "multiple_choice",
    "question_text": "What are feature flags used for?",
    "topic": "software_engineering",
    "answers": [
      {
        "text": "Toggle features on/off without deploying new code",
        "correct": true,
        "response": "Correct! Feature flags enable gradual rollouts and A/B testing.",
        "reward_knowledge": "feature_management"
      },
      {
        "text": "Optimize code performance automatically",
        "correct": false,
        "response": "Feature flags control visibility, not performance."
      },
      {
        "text": "Document features in code",
        "correct": false,
        "response": "That's code comments, not feature flags."
      },
      {
        "text": "Test code coverage",
        "correct": false,
        "response": "That's testing tools, not feature flags."
      }
    ]
  },
  "circuit_breaker_pattern": {
    "type": "multiple_choice",
    "question_text": "What does the circuit breaker pattern do in microservices?",
    "topic": "distributed_systems",
    "answers": [
      {
        "text": "Stops requests to failing services to prevent cascading failures",
        "correct": true,
        "response": "Correct! Circuit breakers provide graceful degradation and fast failure.",
        "reward_knowledge": "resilience_patterns"
      },
      {
        "text": "Routes electricity to servers",
        "correct": false,
        "response": "It's a software pattern, not electrical."
      },
      {
        "text": "Encrypts service-to-service communication",
        "correct": false,
        "response": "That's service mesh or TLS, not circuit breakers."
      },
      {
        "text": "Balances load between services",
        "correct": false,
        "response": "That's load balancing, not circuit breaking."
      }
    ]
  },
  "immutable_infrastructure": {
    "type": "yes_no",
    "question_text": "In immutable infrastructure, do you replace servers rather than update them?",
    "topic": "devops",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Immutable infrastructure prevents configuration drift.",
    "incorrect_response": "Yes - you deploy new servers instead of modifying existing ones."
  },
  "service_mesh": {
    "type": "short_answer",
    "question_text": "What pattern manages service-to-service communication in microservices?",
    "topic": "distributed_systems",
    "correct_answer": "service mesh|servicemesh|service-mesh",
    "match_type": "exact",
    "correct_response": "Correct! Service mesh handles routing, security, and observability between services.",
    "incorrect_response": "Think about a mesh or network layer for microservices communication.",
    "reward_knowledge": "service_mesh"
  },
  "chaos_engineering": {
    "type": "multiple_choice",
    "question_text": "What is chaos engineering?",
    "topic": "devops",
    "answers": [
      {
        "text": "Intentionally breaking production to test resilience",
        "correct": true,
        "response": "Correct! Chaos engineering finds weaknesses before real outages do.",
        "reward_knowledge": "chaos_engineering"
      },
      {
        "text": "Having no deployment process",
        "correct": false,
        "response": "It's controlled experimentation, not chaos in process."
      },
      {
        "text": "Random code refactoring",
        "correct": false,
        "response": "It's about system resilience testing, not code changes."
      },
      {
        "text": "Testing without documentation",
        "correct": false,
        "response": "Chaos engineering is well-documented and controlled."
      }
    ]
  },
  "message_queue_purpose": {
    "type": "multiple_choice",
    "question_text": "What is the main purpose of message queues (like RabbitMQ, Kafka)?",
    "topic": "distributed_systems",
    "answers": [
      {
        "text": "Decouple services and enable asynchronous communication",
        "correct": true,
        "response": "Correct! Queues buffer messages and enable reliable async processing.",
        "reward_knowledge": "message_queues"
      },
      {
        "text": "Store user session data",
        "correct": false,
        "response": "That's session storage, not message queues."
      },
      {
        "text": "Replace databases entirely",
        "correct": false,
        "response": "Queues complement databases, don't replace them."
      },
      {
        "text": "Speed up synchronous API calls",
        "correct": false,
        "response": "Queues are for async communication, not speeding up sync calls."
      }
    ]
  },
  "horizontal_vs_vertical_scaling": {
    "type": "short_answer",
    "question_text": "Adding more servers is called _____ scaling. (horizontal or vertical?)",
    "topic": "distributed_systems",
    "correct_answer": "horizontal|Horizontal",
    "match_type": "exact",
    "correct_response": "Correct! Horizontal scaling adds more machines. Vertical scaling adds more power to one machine.",
    "incorrect_response": "Think: horizontal = more machines, vertical = bigger machine.",
    "reward_knowledge": "scaling_strategies"
  },
  "quicksort_complexity": {
    "type": "short_answer",
    "question_text": "What is the average-case time complexity of quicksort?",
    "topic": "algorithms",
    "correct_answer": "O(n log n)|O(nlogn)|n log n|nlogn|linearithmic|quasilinear",
    "match_type": "complexity",
    "correct_response": "Correct! Quicksort averages O(n log n), though worst case is O(n\u00b2).",
    "incorrect_response": "Think about how quicksort divides and conquers the array.",
    "reward_knowledge": "quicksort"
  },
  "bfs_graph_traversal": {
    "type": "short_answer",
    "question_text": "What algorithm uses a queue to explore graph nodes level by level?",
    "topic": "algorithms",
    "correct_answer": "BFS|Breadth-First Search|breadth first search|breadth-first|breadthfirst",
    "match_type": "exact",
    "correct_response": "Correct! BFS uses a queue for level-order traversal.",
    "incorrect_response": "Think about the algorithm that explores neighbors before going deeper.",
    "reward_knowledge": "bfs"
  },
  "linked_list_insertion": {
    "type": "short_answer",
    "question_text": "What is the time complexity of inserting at the head of a linked list?",
    "topic": "data_structures",
    "correct_answer": "O(1)|constant|1",
    "match_type": "complexity",
    "correct_response": "Correct! Insertion at the head is O(1) - just update the head pointer.",
    "incorrect_response": "Think about how many steps it takes to add a node at the start.",
    "reward_knowledge": "linked_list"
  },
  "stack_lifo": {
    "type": "yes_no",
    "question_text": "Does a stack follow Last-In-First-Out (LIFO) order?",
    "topic": "data_structures",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Stacks are LIFO - last item pushed is first popped.",
    "incorrect_response": "Yes - stacks are LIFO (like a stack of plates)."
  },
  "binary_tree_height": {
    "type": "short_answer",
    "question_text": "What is the height of a balanced binary tree with n nodes? (Big-O notation)",
    "topic": "data_structures",
    "correct_answer": "O(log n)|O(logn)|log n|logn|logarithmic",
    "match_type": "complexity",
    "correct_response": "Correct! Balanced trees have O(log n) height.",
    "incorrect_response": "Think about how height grows as you double the nodes.",
    "reward_knowledge": "binary_tree"
  },
  "heap_extract_max": {
    "type": "short_answer",
    "question_text": "What is the time complexity of extracting the maximum from a max heap?",
    "topic": "data_structures",
    "correct_answer": "O(log n)|O(logn)|log n|logn|logarithmic",
    "match_type": "complexity",
    "correct_response": "Correct! Extract-max requires O(log n) to restore heap property.",
    "incorrect_response": "Consider the height of the heap and the bubbling down process.",
    "reward_knowledge": "heap"
  },
  "process_vs_thread": {
    "type": "yes_no",
    "question_text": "Do threads within a process share the same memory space?",
    "topic": "systems",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Threads share memory, making communication fast but requiring synchronization.",
    "incorrect_response": "Yes - threads share memory within a process, unlike separate processes."
  },
  "deadlock_conditions": {
    "type": "short_answer",
    "question_text": "How many conditions must hold simultaneously for deadlock to occur?",
    "topic": "systems",
    "correct_answer": "4|four",
    "match_type": "numeric",
    "correct_response": "Correct! The 4 conditions: mutual exclusion, hold and wait, no preemption, circular wait.",
    "incorrect_response": "There are exactly 4 necessary conditions for deadlock.",
    "reward_knowledge": "deadlock"
  },
  "virtual_memory_purpose": {
    "type": "multiple_choice",
    "question_text": "What is the main benefit of virtual memory?",
    "topic": "systems",
    "answers": [
      {
        "text": "Programs can use more memory than physically available",
        "correct": true,
        "response": "Correct! Virtual memory uses disk as extended RAM.",
        "reward_knowledge": "virtual_memory"
      },
      {
        "text": "Programs run faster",
        "correct": false,
        "response": "Virtual memory can actually slow things down due to disk access."
      },
      {
        "text": "Programs use less CPU",
        "correct": false,
        "response": "Virtual memory doesn't reduce CPU usage."
      },
      {
        "text": "Programs become smaller",
        "correct": false,
        "response": "It's about available memory, not program size."
      }
    ]
  },
  "cache_miss_types": {
    "type": "yes_no",
    "question_text": "Is a cache miss when requested data is NOT found in the cache?",
    "topic": "systems",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! A miss requires fetching from slower memory.",
    "incorrect_response": "Yes - a miss means the data must be fetched from main memory."
  },
  "tcp_reliable": {
    "type": "yes_no",
    "question_text": "Does TCP guarantee reliable, ordered delivery of data?",
    "topic": "networking",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! TCP ensures reliability through acknowledgments and retransmission.",
    "incorrect_response": "Yes - TCP is reliable and ordered, unlike UDP."
  },
  "http_port": {
    "type": "short_answer",
    "question_text": "What is the default port number for HTTP?",
    "topic": "networking",
    "correct_answer": "80",
    "match_type": "exact",
    "correct_response": "Correct! HTTP uses port 80 (HTTPS uses 443).",
    "incorrect_response": "Think about the standard HTTP port (not HTTPS).",
    "reward_knowledge": "http"
  },
  "dns_purpose": {
    "type": "short_answer",
    "question_text": "What does DNS stand for?",
    "topic": "networking",
    "correct_answer": "Domain Name System|domain name system|DNS",
    "match_type": "exact",
    "correct_response": "Correct! DNS translates domain names to IP addresses.",
    "incorrect_response": "Think about the system that translates names to IP addresses.",
    "reward_knowledge": "dns"
  },
  "three_way_handshake": {
    "type": "short_answer",
    "question_text": "How many steps are in TCP's connection establishment handshake?",
    "topic": "networking",
    "correct_answer": "3|three",
    "match_type": "numeric",
    "correct_response": "Correct! TCP uses a 3-way handshake: SYN, SYN-ACK, ACK.",
    "incorrect_response": "It's called the 'three-way' handshake for a reason!",
    "reward_knowledge": "tcp"
  },
  "acid_properties": {
    "type": "yes_no",
    "question_text": "Do ACID properties ensure database transaction reliability?",
    "topic": "databases",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! ACID (Atomicity, Consistency, Isolation, Durability) ensures reliable transactions.",
    "incorrect_response": "Yes - ACID properties are fundamental to reliable database transactions."
  },
  "index_speedup": {
    "type": "yes_no",
    "question_text": "Do database indexes speed up SELECT queries but slow down INSERT/UPDATE?",
    "topic": "databases",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Indexes are a classic time-space tradeoff.",
    "incorrect_response": "Yes - indexes speed up reads but add overhead to writes."
  },
  "normalization_purpose": {
    "type": "multiple_choice",
    "question_text": "What is the main purpose of database normalization?",
    "topic": "databases",
    "answers": [
      {
        "text": "Reduce data redundancy and improve data integrity",
        "correct": true,
        "response": "Correct! Normalization eliminates duplicate data and ensures consistency.",
        "reward_knowledge": "normalization"
      },
      {
        "text": "Make queries run faster",
        "correct": false,
        "response": "Normalization can actually slow some queries (requiring joins)."
      },
      {
        "text": "Reduce database size on disk",
        "correct": false,
        "response": "It's about integrity, not primarily size."
      },
      {
        "text": "Encrypt sensitive data",
        "correct": false,
        "response": "That's data encryption, not normalization."
      }
    ]
  },
  "symmetric_vs_asymmetric": {
    "type": "multiple_choice",
    "question_text": "What's the key difference between symmetric and asymmetric encryption?",
    "topic": "security",
    "answers": [
      {
        "text": "Symmetric uses one key, asymmetric uses a key pair",
        "correct": true,
        "response": "Correct! Symmetric is faster, asymmetric enables secure key exchange.",
        "reward_knowledge": "encryption"
      },
      {
        "text": "Symmetric is more secure than asymmetric",
        "correct": false,
        "response": "Both can be secure; they serve different purposes."
      },
      {
        "text": "Asymmetric is always faster",
        "correct": false,
        "response": "Symmetric encryption is generally faster."
      },
      {
        "text": "Symmetric requires a certificate authority",
        "correct": false,
        "response": "That's related to asymmetric crypto, not symmetric."
      }
    ]
  },
  "hash_collision": {
    "type": "yes_no",
    "question_text": "Is a hash collision when two different inputs produce the same hash?",
    "topic": "security",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Collisions are rare in good hash functions but mathematically inevitable.",
    "incorrect_response": "Yes - a collision means different inputs hash to the same value."
  },
  "https_encryption": {
    "type": "yes_no",
    "question_text": "Does HTTPS encrypt data between client and server?",
    "topic": "security",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! HTTPS uses TLS/SSL to encrypt HTTP traffic.",
    "incorrect_response": "Yes - HTTPS adds encryption to HTTP using TLS/SSL."
  },
  "greedy_algorithm": {
    "type": "yes_no",
    "question_text": "Does a greedy algorithm always make the locally optimal choice at each step?",
    "topic": "algorithms",
    "correct_answer": "yes|true|y",
    "correct_response": "Correct! Greedy algorithms choose the best immediate option (not always globally optimal).",
    "incorrect_response": "Yes - greedy algorithms make locally optimal choices, which may not be globally optimal."
  },
  "dynamic_programming": {
    "type": "multiple_choice",
    "question_text": "What technique does dynamic programming use to avoid redundant calculations?",
    "topic": "algorithms",
    "answers": [
      {
        "text": "Memoization (caching results)",
        "correct": true,
        "response": "Correct! DP stores subproblem solutions to avoid recalculation.",
        "reward_knowledge": "dynamic_programming"
      },
      {
        "text": "Using faster hardware",
        "correct": false,
        "response": "DP is an algorithmic technique, not hardware optimization."
      },
      {
        "text": "Parallel processing",
        "correct": false,
        "response": "While possible, memoization is the core DP technique."
      },
      {
        "text": "Skipping validation checks",
        "correct": false,
        "response": "DP doesn't skip checks, it caches results."
      }
    ]
  },
  "trie_search_complexity": {
    "type": "short_answer",
    "question_text": "What is the time complexity of searching for a word of length k in a trie?",
    "topic": "data_structures",
    "correct_answer": "O(k)|k|O(length)|linear",
    "match_type": "complexity",
    "correct_response": "Correct! Trie search is O(k) where k is the word length.",
    "incorrect_response": "Think about how many characters you need to check in the word.",
    "reward_knowledge": "trie"
  },
  "mvc_pattern": {
    "type": "multiple_choice",
    "question_text": "In the MVC (Model-View-Controller) pattern, what is the Controller's responsibility?",
    "topic": "architecture",
    "answers": [
      {
        "text": "Handle user input and update Model/View",
        "correct": true,
        "response": "Correct! The Controller receives input, updates the Model, and tells the View to refresh. It's the glue between Model and View.",
        "reward_knowledge": "mvc_architecture"
      },
      {
        "text": "Store and manage application data",
        "correct": false,
        "response": "That's the Model's job. The Controller orchestrates interactions between Model and View."
      },
      {
        "text": "Render the user interface",
        "correct": false,
        "response": "That's the View's responsibility. The Controller handles input and coordinates updates."
      },
      {
        "text": "Directly manipulate the database",
        "correct": false,
        "response": "The Controller delegates data operations to the Model, it doesn't access the database directly."
      }
    ]
  },
  "layered_architecture": {
    "type": "multiple_choice",
    "question_text": "In layered architecture, what is the key rule?",
    "topic": "architecture",
    "answers": [
      {
        "text": "Each layer can only depend on layers below it",
        "correct": true,
        "response": "Correct! Layers should only call down the stack (presentation  business  data). This creates clear separation and maintainability.",
        "reward_knowledge": "layered_architecture"
      },
      {
        "text": "All layers can call any other layer",
        "correct": false,
        "response": "That would break the layering principle. Layers should only depend on layers below them."
      },
      {
        "text": "Layers can only communicate through events",
        "correct": false,
        "response": "That's event-driven architecture. Layered architecture uses direct calls to lower layers."
      },
      {
        "text": "Each layer must use a different programming language",
        "correct": false,
        "response": "Language choice is independent of layering. Layering is about logical separation."
      }
    ]
  },
  "transaction_isolation": {
    "type": "multiple_choice",
    "question_text": "What does the SERIALIZABLE isolation level guarantee?",
    "topic": "databases",
    "answers": [
      {
        "text": "Transactions execute as if they were serial (one after another)",
        "correct": true,
        "response": "Correct! SERIALIZABLE is the highest isolation level - no phantom reads, non-repeatable reads, or dirty reads. But it's the slowest!",
        "reward_knowledge": "transaction_isolation"
      },
      {
        "text": "Transactions run faster by removing locks",
        "correct": false,
        "response": "Opposite! SERIALIZABLE adds the most locks for maximum consistency, making it slower."
      },
      {
        "text": "Data is serialized to JSON format",
        "correct": false,
        "response": "That's data serialization, not transaction isolation. SERIALIZABLE is about concurrent transaction safety."
      },
      {
        "text": "Transactions are saved to disk immediately",
        "correct": false,
        "response": "That's durability (the D in ACID), not isolation level."
      }
    ]
  },
  "database_indexes": {
    "type": "multiple_choice",
    "question_text": "Why do database indexes typically use B-trees instead of hash tables?",
    "topic": "databases",
    "answers": [
      {
        "text": "B-trees support range queries efficiently",
        "correct": true,
        "response": "Correct! B-trees maintain sorted order, enabling efficient range scans (e.g., WHERE age BETWEEN 20 AND 30). Hash indexes only support equality checks.",
        "reward_knowledge": "database_indexing"
      },
      {
        "text": "Hash tables are slower than B-trees",
        "correct": false,
        "response": "Hash tables are actually faster for equality lookups! But they can't do range queries efficiently."
      },
      {
        "text": "B-trees use less memory",
        "correct": false,
        "response": "Memory isn't the key difference. B-trees enable range queries, which hash tables can't do efficiently."
      },
      {
        "text": "Hash tables can't store strings",
        "correct": false,
        "response": "Hash tables work fine with strings. The issue is they can't support range queries."
      }
    ]
  },
  "denormalization": {
    "type": "multiple_choice",
    "question_text": "When might you intentionally denormalize a database?",
    "topic": "databases",
    "answers": [
      {
        "text": "To improve read performance at the cost of write complexity",
        "correct": true,
        "response": "Correct! Denormalization reduces JOINs for faster reads, but you must maintain duplicate data on writes. It's a performance tradeoff!",
        "reward_knowledge": "denormalization"
      },
      {
        "text": "To eliminate all data redundancy",
        "correct": false,
        "response": "That's normalization! Denormalization intentionally adds redundancy to speed up reads."
      },
      {
        "text": "To make the database smaller",
        "correct": false,
        "response": "Denormalization typically increases storage due to duplicate data. It's about speed, not size."
      },
      {
        "text": "To ensure data integrity",
        "correct": false,
        "response": "Normalization ensures integrity. Denormalization trades some integrity guarantees for performance."
      }
    ]
  },
  "git_rebase": {
    "type": "multiple_choice",
    "question_text": "What is the main advantage of git rebase over git merge?",
    "topic": "version_control",
    "answers": [
      {
        "text": "Creates a linear commit history",
        "correct": true,
        "response": "Correct! Rebase rewrites commits onto the target branch, creating a clean linear history. Merge preserves the branching structure with a merge commit.",
        "reward_knowledge": "git_rebase"
      },
      {
        "text": "Rebase is faster than merge",
        "correct": false,
        "response": "Speed isn't the key difference. Rebase provides cleaner history by avoiding merge commits."
      },
      {
        "text": "Rebase doesn't require conflict resolution",
        "correct": false,
        "response": "Both can have conflicts! Rebase resolves conflicts per commit, merge resolves all at once."
      },
      {
        "text": "Rebase is always safer than merge",
        "correct": false,
        "response": "Rebase rewrites history, which can be dangerous on shared branches. Never rebase published commits!"
      }
    ]
  },
  "git_cherry_pick": {
    "type": "multiple_choice",
    "question_text": "What does 'git cherry-pick' do?",
    "topic": "version_control",
    "answers": [
      {
        "text": "Apply a specific commit from one branch to another",
        "correct": true,
        "response": "Correct! Cherry-pick copies a commit to your current branch. Useful for backporting fixes or selectively merging features.",
        "reward_knowledge": "git_advanced"
      },
      {
        "text": "Delete commits you don't want",
        "correct": false,
        "response": "That would be git reset or git revert. Cherry-pick copies commits, doesn't delete them."
      },
      {
        "text": "Merge all commits from a branch",
        "correct": false,
        "response": "That's git merge. Cherry-pick selects individual commits, not whole branches."
      },
      {
        "text": "Find the best commit in a branch",
        "correct": false,
        "response": "Git doesn't rank commits. You manually choose which commit to cherry-pick."
      }
    ]
  },
  "git_bisect": {
    "type": "multiple_choice",
    "question_text": "What is 'git bisect' used for?",
    "topic": "version_control",
    "answers": [
      {
        "text": "Binary search through commits to find when a bug was introduced",
        "correct": true,
        "response": "Correct! Bisect performs binary search: mark commits as 'good' or 'bad' until it identifies the first bad commit. O(log n) debugging!",
        "reward_knowledge": "git_debugging"
      },
      {
        "text": "Split a repository into two separate repos",
        "correct": false,
        "response": "That's git filter-branch or subtree split. Bisect is for finding bugs in history."
      },
      {
        "text": "Merge two branches automatically",
        "correct": false,
        "response": "That's git merge. Bisect helps debug by finding problematic commits."
      },
      {
        "text": "Compare two files",
        "correct": false,
        "response": "That's git diff. Bisect finds the commit that introduced a bug."
      }
    ]
  },
  "test_coverage": {
    "type": "multiple_choice",
    "question_text": "What does 100% code coverage guarantee?",
    "topic": "testing",
    "answers": [
      {
        "text": "Nothing - it only means all lines were executed, not that they're correct",
        "correct": true,
        "response": "Correct! 100% coverage means every line ran during tests, but doesn't guarantee: correct assertions, edge cases tested, or absence of logic bugs. Coverage is necessary but not sufficient!",
        "reward_knowledge": "test_coverage"
      },
      {
        "text": "The code has no bugs",
        "correct": false,
        "response": "Nope! Coverage measures execution, not correctness. You can execute buggy code in tests without catching the bug."
      },
      {
        "text": "All possible inputs have been tested",
        "correct": false,
        "response": "That would require infinite tests for most programs! Coverage just means each line executed at least once."
      },
      {
        "text": "The code will never throw exceptions",
        "correct": false,
        "response": "Coverage doesn't test error conditions exhaustively. Code can still fail in production."
      }
    ]
  },
  "contract_testing": {
    "type": "multiple_choice",
    "question_text": "What is contract testing in microservices?",
    "topic": "testing",
    "answers": [
      {
        "text": "Verifying that services meet their API contracts with consumers",
        "correct": true,
        "response": "Correct! Contract tests ensure provider APIs match what consumers expect. Tools like Pact detect breaking changes before deployment. Faster and more reliable than full integration tests!",
        "reward_knowledge": "contract_testing"
      },
      {
        "text": "Testing legal contracts in the codebase",
        "correct": false,
        "response": "Not about legal contracts! Contract testing verifies service API agreements in distributed systems."
      },
      {
        "text": "Ensuring code follows style guidelines",
        "correct": false,
        "response": "That's linting, not contract testing. Contract tests verify service interfaces."
      },
      {
        "text": "Testing only the happy path",
        "correct": false,
        "response": "Contract tests cover both success and error scenarios to ensure the full API contract is honored."
      }
    ]
  },
  "snapshot_testing": {
    "type": "multiple_choice",
    "question_text": "What is snapshot testing primarily used for?",
    "topic": "testing",
    "answers": [
      {
        "text": "Detect unintended changes in UI/output by comparing to stored snapshots",
        "correct": true,
        "response": "Correct! Snapshot tests save output (like rendered HTML) and fail if it changes. Great for UIs - catch unexpected regressions quickly. But beware: blindly updating snapshots defeats the purpose!",
        "reward_knowledge": "snapshot_testing"
      },
      {
        "text": "Test database backups",
        "correct": false,
        "response": "That's database snapshot testing (different concept). UI snapshot testing compares rendered output."
      },
      {
        "text": "Take screenshots during test execution",
        "correct": false,
        "response": "Visual regression testing takes screenshots. Snapshot testing compares serialized output (like HTML or JSON)."
      },
      {
        "text": "Measure test execution time",
        "correct": false,
        "response": "That's performance testing. Snapshot testing detects unintended output changes."
      }
    ]
  },
  "hexagonal_architecture": {
    "type": "multiple_choice",
    "question_text": "What is the key principle of Hexagonal Architecture (Ports and Adapters)?",
    "topic": "architecture",
    "answers": [
      {
        "text": "Isolate business logic from external concerns via ports and adapters",
        "correct": true,
        "response": "Correct! The core domain is at the center with 'ports' (interfaces). 'Adapters' implement ports for specific technologies (DB, UI, APIs). Easy to swap implementations and test!",
        "reward_knowledge": "hexagonal_architecture"
      },
      {
        "text": "Use six-sided polygons for data structures",
        "correct": false,
        "response": "Not about shapes! Hexagonal architecture isolates business logic from infrastructure through abstraction layers."
      },
      {
        "text": "Deploy applications across six servers",
        "correct": false,
        "response": "Nothing to do with deployment. It's about separating business logic from technical implementation details."
      },
      {
        "text": "Everything must be a microservice",
        "correct": false,
        "response": "Hexagonal architecture works for monoliths too! It's about separation of concerns, not service boundaries."
      }
    ]
  },
  "cqrs_pattern": {
    "type": "multiple_choice",
    "question_text": "What does CQRS (Command Query Responsibility Segregation) separate?",
    "topic": "architecture",
    "answers": [
      {
        "text": "Read operations (queries) from write operations (commands)",
        "correct": true,
        "response": "Correct! CQRS uses separate models for reads and writes. Write model focuses on consistency, read model optimized for queries. Enables different scaling strategies!",
        "reward_knowledge": "cqrs"
      },
      {
        "text": "Frontend from backend code",
        "correct": false,
        "response": "That's just layering. CQRS separates read and write data models, often in the same backend."
      },
      {
        "text": "SQL queries from NoSQL queries",
        "correct": false,
        "response": "CQRS is database-agnostic. It's about separating reads from writes, regardless of database technology."
      },
      {
        "text": "Authentication from authorization",
        "correct": false,
        "response": "That's a security concern. CQRS is about separating query and command data paths."
      }
    ]
  },
  "eventual_consistency_example": {
    "type": "multiple_choice",
    "question_text": "Which scenario best demonstrates eventual consistency?",
    "topic": "distributed_systems",
    "answers": [
      {
        "text": "Social media likes count may temporarily differ across users but converges",
        "correct": true,
        "response": "Correct! When you like a post, different users might see different counts briefly, but they'll eventually all see the same number. Classic eventual consistency - prioritizing availability!",
        "reward_knowledge": "eventual_consistency"
      },
      {
        "text": "Bank transactions that must be immediately consistent",
        "correct": false,
        "response": "Banks require strong consistency! Money transfers can't be 'eventually correct' - you need ACID guarantees."
      },
      {
        "text": "A single-server database with no replication",
        "correct": false,
        "response": "Single servers don't have consistency issues. Eventual consistency is about distributed systems with replicas."
      },
      {
        "text": "Caching that never expires",
        "correct": false,
        "response": "That's permanent inconsistency! Eventual consistency means replicas will eventually agree, not stay stale forever."
      }
    ]
  }
}